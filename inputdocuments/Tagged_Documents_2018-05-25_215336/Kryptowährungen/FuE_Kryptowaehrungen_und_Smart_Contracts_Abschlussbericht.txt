KRYPTOWĂHRUNGEN UND SMART CONTRACTS
Marius Spancken, Mario Hellenkamp, Christopher Brown, Christian Thiel

Abschlussbericht zum Forschungs- und Entwicklungsprojekt 2015/2016
im Studiengang Master of Science Wirtschaftsinformatik
an der FH MĂźnster

Dozent: Prof. Dr. Claus Grewe
Fachbereich Wirtschaft | MĂźnster School of Business
Abgabe: 12.02.2016

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

Vorwort
Das Curriculum des Studiengangs Master of Science Wirtschaftsinformatik an der FH
MĂźnster beinhaltet das Wahlpflichtmodul âForschungs- und Entwicklungsprojektâ. Das
Modul ermĂśglicht es Masterstudierenden, sich forschungsorientiert mit innovativen
Themen auseinanderzusetzen. Die behandelten Themen werden von Jahr zu Jahr neu
gewĂ¤hlt und umfassen sowohl aktuelle Forschungsgebiete als auch Innovationen, die den
IT-Markt bzw. die Wirtschaftsinformatik gerade erreichen bzw. noch nicht durchdrungen
haben.
Das Forschungs- und Entwicklungsprojekt 2015/2016 zum Thema âKryptowĂ¤hrungen und
Smart Contractsâ startete im September 2015 und lief bis Februar 2016. Das Projektteam
umfasste die vier Mitglieder Marius Spancken, Mario Hellenkamp, Christopher Brown
und Christian Thiel. Gemeinsam fertigten sie den vorliegenden Abschlussbericht an.
Eines der definierten Projektziele bestand in der Analyse der Einsatzzwecke, Potenziale
und Architekturen von Blockchain-Anwendungen. Des Weiteren sollten verschiedene
Fragestellungen zum Nutzen in modernen GeschĂ¤ftsprozessen und zu den technischen
Herausforderungen mittels der Entwicklung eigener Prototypen geklĂ¤rt werden:
-

Wie lĂ¤sst sich eine Blockchain mittels 51-Prozent-Attacke nachtrĂ¤glich doch noch
modifizieren?
Wie sieht eine konkrete Smart-Contract-Implementierung einer verteilten
Clearinghouse-Anwendung in Ethereum aus?

Der vorliegende Bericht vermittelt einen guten Ăberblick Ăźber AnsĂ¤tze, Strukturen,
interne AblĂ¤ufe und Rahmenbedingungen aktueller Blockchain-Implementierungen. Die
erzielten Ergebnisse verdeutlichen neben dem Nutzen auch die Besonderheiten und
EinschrĂ¤nkungen der Blockchain-Technologie.

MĂźnster, im September 2016
Prof. Dr. Claus Grewe

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

Markenrechtlicher Hinweis
Die in dieser Arbeit wiedergegebenen Gebrauchsnamen, Handelsnamen, Warenzeichen
usw. kĂśnnen auch ohne besondere Kennzeichnung geschĂźtzte Marken sein und als solche
den gesetzlichen Bestimmungen unterliegen.

SĂ¤mtliche in dieser Arbeit abgedruckten BildschirmabzĂźge unterliegen dem Urheberrecht
ÂŠ des jeweiligen Herstellers.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

I

Inhaltsverzeichnis
AbkĂźrzungsverzeichnis ..................................................................................................... 1
Tabellenverzeichnis .......................................................................................................... 2
Abbildungsverzeichnis ...................................................................................................... 3
1

Einleitung ................................................................................................................... 5

2

Grundlagen ................................................................................................................ 6

2.1

KryptowĂ¤hrungen ............................................................................................................ 6

2.2

Smart Contracts ............................................................................................................... 7

2.3

Rechtliche Einordnung ..................................................................................................... 9

3
3.1

Funktionsweise der Blockchain-Technologie ............................................................. 12
Komponenten ................................................................................................................ 12
3.1.1 Transaktion .......................................................................................................... 13
3.1.2 Block ..................................................................................................................... 16
3.1.3 Dezentrales Netzwerk/Applikation ...................................................................... 17

3.2

Grundlage die Kryptografie ............................................................................................ 18
3.2.1 Digitale Signaturen ............................................................................................... 19
3.2.2 Kryptografische Hashfunktionen ......................................................................... 19

3.3

Von der Transaktion zum validierten Block ................................................................... 21
3.3.1 Verbinden mit dem Blockchain-Netzwerk ........................................................... 21
3.3.2 Erstellung und publizieren einer Transaktion ...................................................... 23
3.3.3 Blockgenerierung und Validierung ...................................................................... 25

3.4
4

Kritische Reflexion ......................................................................................................... 27
Prototypische Implementierung einer Blockchain ..................................................... 29

4.1

Funktionale und nicht-funktionale Anforderungen an die Implementation ................. 29

4.2

Bestandteile einer Blockchain-Implementation ............................................................ 29
4.2.1 Entwicklungs- und Testumgebung ....................................................................... 29

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

II

4.2.2 Programmaufbau ................................................................................................. 30
4.2.3 Grundelemente .................................................................................................... 30
4.2.4 Blockgenerierung ................................................................................................. 31
4.2.5 Kryptografische PrĂźfungen .................................................................................. 32
4.2.6 Proof-of-Work ...................................................................................................... 34
4.2.7 Netzwerkkommunikation .................................................................................... 35
4.2.8 Wallet-Anwendung .............................................................................................. 38
4.3

Sicherheit einer Blockchain â Angriffsszenarien............................................................ 39
4.3.1 Alternative Proof-Of-Konzepte ............................................................................ 39
4.3.2 Theoretische Angriffe auf Blockchain-Konzepte ................................................. 42
4.3.3 Abwehrmechanismen .......................................................................................... 44
4.3.4 Versuch: Angriff auf den Prototyp (Proof-of-Work) ............................................ 46

4.4
5

Kritische Reflexion ......................................................................................................... 48
Fachliche Konzeption eines Smart Contracts ............................................................. 50

5.1

EinfĂźhrung in den Derivathandel ................................................................................... 50

5.2

Idee ................................................................................................................................ 53

5.3

Rechtliche und praktische EinschrĂ¤nkung ..................................................................... 57

6

Smart Oracles........................................................................................................... 59

6.1

Problemstellung ............................................................................................................. 59

6.2

LĂśsungsansĂ¤tze .............................................................................................................. 59
6.2.1 Distributed Oracles .............................................................................................. 60
6.2.2 Reality Keys .......................................................................................................... 61
6.2.3 Oraclize ................................................................................................................ 61

7
7.1

Prototypische Implementierung des Smart Contracts ............................................... 63
Auswahl von Smart Contract und DAPP-Plattform........................................................ 63
7.1.1 Plattformen .......................................................................................................... 63

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

III

7.1.2 Auswahl der Smart Contract-Plattform ............................................................... 65
7.1.3 Aufbau und Komponenten von Ethereum........................................................... 65
7.1.4 Interkation mit dem Ethereum-Netzwerk und dem Smart Contract .................. 67
7.2

Werkzeuge und Plattformen.......................................................................................... 68
7.2.1 Programmiersprachen ......................................................................................... 68
7.2.2 Entwicklungswerkzeuge ....................................................................................... 69
7.2.3 Frameworks ......................................................................................................... 70
7.2.4 Laufzeitumgebung ............................................................................................... 70

7.3

Prototypische Umsetzung des Smart Oracles................................................................ 71
7.3.1 Funktionale Anforderung ..................................................................................... 71
7.3.2 Nicht-funktionale Anforderungen ....................................................................... 72
7.3.3 Konzeption des Smart Oracles ............................................................................. 72
7.3.4 Eingesetzte Technologien .................................................................................... 74
7.3.5 Datenquelle .......................................................................................................... 74
7.3.6 Umsetzung ........................................................................................................... 74
7.3.7 Kritische Reflexion und Ausblick .......................................................................... 78

7.4

Technische Konzeption des Clearinghouse-Smart Contracts ........................................ 79
7.4.1 Nicht-funktionale Anforderungen ....................................................................... 79
7.4.2 Funktionale Anforderungen ................................................................................. 79
7.4.3 Herausforderungen .............................................................................................. 81
7.4.4 Konzeption des Clearinghouse-Smart Contracts ................................................. 82
7.4.5 Konzeption der dezentralen Applikation ............................................................. 83

7.5

Umsetzung des Clearinghouse-DAPP-Prototyps ........................................................... 84
7.5.1 OberflĂ¤che............................................................................................................ 84
7.5.2 Schutz vor unbefugter AusfĂźhrung und Ănderung .............................................. 85
7.5.3 Aufsetzen des Derivat-Vertrags ........................................................................... 85

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

IV

7.5.4 Einzahlung von Margin ........................................................................................ 86
7.5.5 AuflĂśsen des Derivat-Vertrags ............................................................................. 86
7.5.6 Abruf von internen Vertragsdaten....................................................................... 87
7.5.7 Aktualisierung von Marktdaten durch Dritte ...................................................... 88
7.5.8 Registrierung am Oracle ...................................................................................... 89
7.6
8

Kritische Reflexion und Ausblick .................................................................................... 89
Fazit ......................................................................................................................... 91

Literaturverzeichnis ........................................................................................................ 93
Anhang........................................................................................................................... 99

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

AbkĂźrzungsverzeichnis
AES

Advanced Encryption Standard

API

Application Programming Interface

BPMN

Business Process Model and Notation

DNS

Domain Name System

DSA

Digital Signature Algorithm

ECB

European Central Bank

ECDSA

Elliptic Curve Digital Signature Algorithm

JSON

JavaScript Object Notation

KG

KontraktgrĂśĂe

KP

Kontraktpreis

KWG

Kreditwesengesetz

POA

Proof-of-Activity

POB

Proof-of-Burn

POC

Proof-of-Capacity

POS

Proof-of-Stack

POW

Proof-of-Work

RIPEDM

RACE Integrity Primitives Evaluation Message Digest

RPC

Remote Procedure Call

RSA

Rivest, Shamir und Adleman

SHA

Secure Hash Algorithm

TCP

Transmission Control Protocol

TLS

Transport Layer Security

XML

Extensible Markup Language

SEITE

1

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

2

Tabellenverzeichnis
Tabelle 1: Top 5 KryptowĂ¤hrungen nach Marktkapitalisierung (Coinmarketcap) ................ 6
Tabelle 2: Beispiel Clearinghouse .................................................................................... 52
Tabelle 3: Endrechnung Unternehmen A ......................................................................... 52
Tabelle 4: Endrechnung Unternehmen B ......................................................................... 53
Tabelle 5: Entwicklungsumgebung .................................................................................100
Tabelle 6: Vergleich der Frameworks ..............................................................................112

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

3

Abbildungsverzeichnis
Abbildung 1: Ăberblick Blockchain-Komponenten ........................................................... 12
Abbildung 2: Grundlegender Transaktionsaufbau ............................................................ 14
Abbildung 3: Signieren und validieren einer Transaktion ................................................. 15
Abbildung 4: Grundlegender Blockaufbau ....................................................................... 16
Abbildung 5: Rollen im Blockchain-Netzwerk .................................................................. 18
Abbildung 6: Digitale Signatur am Beispiel - Transaktion ................................................. 19
Abbildung 7: Kryptografische Hashfunktion am Beispiel - Transaktion ............................. 20
Abbildung 8: VerknĂźpfung von Input und Output zweier Transaktionen .......................... 24
Abbildung 9: Transaktion - Beispiel Input/Output-Verteilung .......................................... 24
Abbildung 10: Block hashing Algorithmus â Hashcash ...................................................... 26
Abbildung 11: Grundelemente eine Blockchain ............................................................... 30
Abbildung 12: Codeausschnitt: Proof-of-Work ................................................................. 34
Abbildung 13: Broadcast der Mineradresse ..................................................................... 35
Abbildung 14: Versendung eines Blocks .......................................................................... 36
Abbildung 15: Empfang eines Blocks ............................................................................... 38
Abbildung 16: Erfolgreiche Doppelausgabe ..................................................................... 43
Abbildung 17: NachtrĂ¤gliche VerĂ¤nderungen durch einen Angreifer ................................ 44
Abbildung 18: Gescheiterte Doppelausgabe .................................................................... 45
Abbildung 19: BPMN-Diagramm des GeschĂ¤ftsvorfalls Abschnitt 1 .................................. 54
Abbildung 20: BPMN-Diagramm des GeschĂ¤ftsvorfalls Abschnitt 2 .................................. 55
Abbildung 21: Clearing im Smart Contract ....................................................................... 56
Abbildung 22: BPMN-Diagramm des GeschĂ¤ftsvorfalls Abschnitt 3 .................................. 57
Abbildung 23: Konzept von Smart Oracles nach Codius.................................................... 64
Abbildung 24: Ethereum Technologie Stack ..................................................................... 65
Abbildung 25: Interkation mittels DAPP und Ethereum-Netzwerk.................................... 67
Abbildung 26: Prozessablauf Smart Oracle ...................................................................... 73
Abbildung 27: Quellcode Oracle Contract ........................................................................ 75

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

4

Abbildung 28: Klassendiagramm Oracle (Java-Anwendung) ............................................. 77
Abbildung 29: Klassendiagramme Clearinghouse Smart Contract ..................................... 82
Abbildung 30: Software-Architektur der Clearinghouse DAPP .......................................... 83
Abbildung 31: Deployment von Kontrakt......................................................................... 84
Abbildung 32: Kontrakt-Informationen ........................................................................... 84
Abbildung 33: Oracle initiiert Preisaktualisierung ............................................................ 88
Abbildung 34: Komponenten-Diagramm des Miners ......................................................101
Abbildung 35: Klassendiagramm Mininganwendung ......................................................102
Abbildung 36: Klassendiagramm der Wallet-Anwendung................................................103
Abbildung 37: Klassendiagramm Visualisierungsanwendung ..........................................104
Abbildung 38: Blockgenerierung Ăbersicht .....................................................................104
Abbildung 39: Blockgenerierung Detailansicht................................................................105
Abbildung 40: Angriff auf den Prototyp - Erscheinen des Angreifers ...............................106
Abbildung 41: Angriff auf den Prototyp - Angreifer ist gleichauf .....................................106
Abbildung 42: Angriff auf den Prototyp - Angreifer beeinflusst Miner 1 ..........................107
Abbildung 43: Angriff auf den Prototyp - Angreifer beeinflusst Miner 2 ..........................107
Abbildung 44: Basis-Workflow Clearinghouse DAPP .......................................................113
Abbildung 45: Unterprozess prĂźfe KontostĂ¤nde .............................................................114

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

1

SEITE

5

Einleitung

Mit der VerĂśffentlichung des Whitepapers âBitcoin: A Peer-to-Peer Electronic Cash Systemâ
von Satoshi Nakamoto im Jahre 2009 startete die erste praktische Umsetzung einer
KryptowĂ¤hrung, dem Bitcoin. ZunĂ¤chst als Fundament der KryptowĂ¤hrung Bitcoin entwickelt,
fĂźhrten aufbauende Entwicklungen zu neuen NutzungsmĂśglichkeiten der Blockchain als
eigenstĂ¤ndige Technologie.
Die vorliegende Ausarbeitung im Rahmen des Forschungs- und Entwicklungsprojekts befasst
sich mit der Blockchain-Technologie und der darauf aufbauenden AnwendungsmĂśglichkeiten.
Insbesondere werden dabei KryptowĂ¤hrungen und Smart Contracts untersucht.
Das Ziel der Ausarbeitung ist es, zunĂ¤chst ein VerstĂ¤ndnis fĂźr die zugrundeliegende
Technologie zu gewinnen. Auf Basis dessen soll ein neuer GeschĂ¤ftsprozess fachlich
ausgearbeitet und prototypisch implementiert werden.
Die Herausforderungen liegen zum einen im frĂźhen Entwicklungsstadium der Technologie und
zum anderen in der VerknĂźpfung der unterschiedlichen Disziplinen wie der verteilten
Infrastruktur, der Kryptographie und der wirtschaftlichen AnwendungsmĂśglichkeit.
In der vorliegenden Arbeit wird zunĂ¤chst ein grundlegendes VerstĂ¤ndnis von
KryptowĂ¤hrungen und Smart Contracts vermittelt. AnschlieĂend wird die Funktionsweise der
Blockchain-Technologie

detailliert

dargestellt.

Darauf

aufbauend

werden

die

Herausforderungen und die Umsetzung einer prototypischen Entwicklung dokumentiert. Der
anschlieĂende Teil geht auf die Thematik von Smart Contracts ein. Dabei wird zuerst ein auf
Smart Contract basierender GeschĂ¤ftsprozess entwickelt, welcher im Rahmen des Projektes
prototypisch samt notwendiger Erweiterungen implementiert wird. AbschlieĂend wird ein
Fazit zur Thematik gezogen sowie ein mittelfristiger Ausblick gegeben.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

2

SEITE

6

Grundlagen

Im nachfolgenden Kapitel werden zuerst die grundlegenden Eigenschaften von
KryptowĂ¤hrungen und Smart Contracts beschrieben, um eine Wissensbasis fĂźr die
Ausarbeitung zu schaffen. AbschlieĂend erfolgt eine rechtliche Einordnung der
KryptowĂ¤hrungen.
2.1

KryptowĂ¤hrungen

Eine KryptowĂ¤hrung stellt ein digitales Zahlungsmittel dar. Dieses Zahlungsmittel als Objekt
hat keinen Warenwert, an den es geknĂźpft ist und klassifiziert sich somit als Fiatgeld (Swan,
2015, S. 10). Die Funktionsweise des digitalen Zahlungssystems wird Ăźber Verfahren der
Kryptografie sowie ein verteiltes dezentrales Netzwerk sichergestellt. Anstelle einer MĂźnze
oder eines bedruckten Geldscheins erhĂ¤lt der Inhaber einer Geldeinheit einen
kryptografischen SchlĂźssel. Dieser SchlĂźssel reprĂ¤sentiert den Tauschwert der Geldeinheit.
Der Wert der Geldeinheit wird durch die Akzeptanz durch Handelspartner bestimmt. Das
Besondere an dieser Form von Zahlungssystemen ist, dass keiner dritten Instanz (z.B. Bank)
vertraut werden muss. Die dritte Instanz wird durch die zugrunde liegende BlockchainTechnologie ersetzt. Die Blockchain beinhaltet somit die gemeinschaftlich erstellte und fĂźr
jeden zugĂ¤ngliche BuchfĂźhrung (Nakamoto, 2009, S. 1). Die Funktionsweise dieser
Technologie wird in Kapitel 3 nĂ¤her betrachtet.
Die erste KryptowĂ¤hrung mit dem Namen âBitcoinâ wurde im Januar 2009 von Satoshi
Nakamoto publiziert. Aus der durchgefĂźhrten Marktanalyse geht hervor, dass aktuell ca. 750
alternative KryptowĂ¤hrungen existieren (siehe Anhang A).

Tabelle 1: Top 5 KryptowĂ¤hrungen nach Marktkapitalisierung (Coinmarketcap)

In Tabelle 1 sind die fĂźnf grĂśĂten KryptowĂ¤hrungen gemessen am Wert der
Marktkapitalisierung aufgefĂźhrt. Die analysierten KryptowĂ¤hrungen unterscheiden sich im
Wesentlichen anhand der folgenden Kriterien:
-

Art der verwendeten Kryptografieverfahren (SHA-2, SHA-3, Scrypt etc.)

-

Verfahren zur Sicherung der Blockchain (z.B. Proof-of-Work, Proof-of-Stake etc.)

-

maximalen Menge an Geldeinheiten (Coins)

-

Zeitspanne, in der neue BlĂścke generiert werden

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

7

Neue Einheiten einer KryptowĂ¤hrung werden durch Mining erzeugt. Das Mining ersetzt die
zentrale Institution (z.B. Zentralbank), die sonst neue Einheiten einer WĂ¤hrung ausgibt. Um in
den Besitz einer KryptowĂ¤hrungseinheit zu kommen, ist neben dem Mining auch der Erwerb
Ăźber diverse Handelsplattformen (z.B. Bitstamp) mĂśglich. In Kapitel 3.3.3 wird das Prinzip des
Mining nĂ¤her betrachtet. Anstelle eines Kontos tritt eine sogenannte Wallet Software. Diese
Software speichert die fĂźr Transaktionen generierten SchlĂźsselpaare (ECDSA-Verfahren). Der
Ăśffentliche SchlĂźssel dient hierbei als âKontonummerâ, auf die ein anderer Teilnehmer
Einheiten Ăźberweisen kann. Wer den passenden privaten SchlĂźssel hat kann Ăźber die
erhaltenen WĂ¤hrungseinheiten verfĂźgen. Die Wallet Software kann auf einem lokalen
Rechner installiert sein oder Ăźber eine BĂśrse als Online-Wallet angeboten werden. Es ist auch
mĂśglich sein âGuthabenâ in Form von SchlĂźsselwertpaaren auszudrucken und somit physisch
rechnerunabhĂ¤ngig zu speichern (Nakamoto, 2009).
2.2

Smart Contracts

In den nachfolgenden Unterkapiteln werden Smart Contracts, dezentrale Applikationen, kurz
DAPPs, in diesem Kontext definiert sowie deren MĂśglichkeiten und EinschrĂ¤nkungen
beschrieben.
Smart Contract
Die Idee von Smart Contracts geht auf eine wissenschaftliche Arbeit von Nick Szabo aus dem
Jahre 1998 zurĂźck. Darin wird erstmals beschrieben, wie vertragliche Beziehungen zwischen
Parteien gesichert Ăźber Computer-Netzwerke mĂśglich sind. Seiner Definition nach sind Smart
Contracts computergesteuerte Transaktionsprotokolle, die die Bedingungen eines Vertrages
ausfĂźhren. Das Ziel ist, die gebrĂ¤uchlichen ZustĂ¤nde von VertrĂ¤gen bzw. Transaktionen, wie
z.B. Zahlungsbedingungen und die Durchsetzbarkeit, einzuhalten. Daneben soll ein mĂśglicher
gegenseitiger Missbrauch der Vertragsparteien minimiert werden. Des Weiteren kann
dadurch eine dritte, vertrauliche Partei unter UmstĂ¤nden entfallen (Szabo, 1998). Eine weitere
Definition von Mark S. Miller von 2003 bezeichnet Smart Contracts als Programme, die
vertragliche Bedingungen und Vereinbarungen zwischen den Vertragsparteien prĂźfen und
durchsetzen kĂśnnen (Miller & Stiegler, 2003).
Weitere Eigenschaften von Smart Contracts sind, dass sie nicht nur Bedingungen prĂźfen
kĂśnnen, sondern auch im Quellcode definierte Aktionen, wie z.B. finanzielle Transaktionen,
ausfĂźhren kĂśnnen. AuĂerdem sind sie dezentral, d.h. sie werden nicht an einer zentralen
Stelle von einem Betreiber als Dienst bereitgestellt, sondern werden von vielen
unterschiedlichen Teilnehmern im Netzwerk ausgefĂźhrt. Dies ist mit der Nutzung der
Blockchain-Technologie verbunden (Swan, 2015, S. 16). Aus diesen Eigenschaften ergeben

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

8

sich sowohl Vorteile, als auch EinschrĂ¤nkungen bei der Portierung von der analogen zur
digitalen Welt, welche in den nachfolgenden Unterkapiteln nĂ¤her beschrieben werden.
DAPP - dezentrale Applikation
Eine dezentralisierte Applikation, kurz DAPP, ist eine Anwendung, die auf Web-Technologien
basiert. So werden DAPPs in JavaScript, HTML5 und CSS geschrieben. Zur AusfĂźhrung einer
Anwendung werden JavaScript-Applikationsplattformen wie, z.B. Node.js, verwendet. Anders
als herkĂśmmliche Web-Anwendungen werden dezentrale Applikationen nicht auf einem
zentralen Webserver bereitgestellt, sondern kĂśnnen von jedem Nutzer nach Konfiguration der
benĂśtigten Laufzeitumgebung, ausgefĂźhrt werden. Im Kontext von Smart Contracts bzw.
Ethereum sind DAPPs eine Kombination eines in Web-Sprachen geschriebenen Frontends und
eines Smart Contracts als Backend-Komponente (Johnston, et al., 2014).
Nutzen und MĂśglichkeiten
Nutzen und MĂśglichkeiten ergeben sich vor allem dadurch, dass es sich bei Smart Contracts
um Algorithmen handelt und keine menschliche Interaktion, z.B. zur PrĂźfung von vertraglich
vereinbarten Bedingungen, nĂśtig ist. Dadurch erzielt man zum einen Kostenersparnisse , z.B.
keine Anwaltskosten, sondern nur geringe Kosten zum AusfĂźhren der Operationen, als auch
Zeitersparnisse, da kein Mensch die PrĂźfung vornehmen muss, denn diese lĂ¤uft automatisiert
ab (Swan, 2015, S. 16). Durch die Verlagerung von einer zentralen Stelle, welcher die
Vertragsparteien zur PrĂźfung vertrauen mĂźssen, z.B. einem Clearinghouse, hin zur
DezentralitĂ¤t und damit einhergehend, dass Vertrauen bzw. der Konsens auf der Grundlage
von Vielen basiert, entfĂ¤llt ebenso der Mittelsmann, der zum gegenwĂ¤rtigen Zeitpunkt vor
allem bei finanzielle Transaktionen zwischen den Vertragsparteien steht. Der Mittelsmann
wird in diesem Fall durch einen Algorithmus ersetzt, der im Quellcode fest definierte
PrĂźfungen zur Abwicklungen von VertrĂ¤gen durchfĂźhrt (siehe Definition Smart Contract).
Daraus resultiert vor allem eine optimierte VertragsfĂźhrung. Anders als in Gesetzgebungen
Ăźblich gibt es hier keinen Interpretationsspielraum. Die PrĂźfungen sind nicht vage gehalten,
um den Juristen je nach Situation, einen Entscheidungsspielraum zu geben. Unter UmstĂ¤nden
kĂśnnen dadurch Rechtsstreitigkeiten vermieden werden, da die vertraglichen Bedingungen
nicht Ă¤nderbar in einem Smart Contract vorliegen (Swan, 2015, S. 17).
Die AnwendungsfĂ¤lle liegen derzeit vor allem im Bereich der Finanzbranche. Alle GeschĂ¤fte,
die auf finanzielle Transaktionen oder vertragliche Vereinbarungen aufbauen, kĂśnnen durch
Smart Contracts automatisiert abgewickelt werden. Aus diesem Grunde gehen verstĂ¤rkt
GroĂbanken und Finanzdienstleister in Kooperation mit Beratungsunternehmen das Thema
der Blockchain-Technologie und Smart Contracts an, die neue MĂśglichkeiten zu eruieren
(Honsel, 2015).

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

9

EinschrĂ¤nkungen
Zum gegenwĂ¤rtigen Zeitpunkt ist die Idee von Smart Contracts in der realen Welt noch nicht
angekommen. Wie bereits erwĂ¤hnt, ist Bitcoin als KryptowĂ¤hrung bereits in der Ăffentlichkeit
bekannt. Smart Contracts in diesem Sinne noch nicht. Hier scheitert es oft bei der
Transformation von der digitalen zur physischen Welt sowie bei der rechtlichen
Durchsetzbarkeit von Bedingungen, die im Smart Contract festgelegt werden. Als
ĂbergangslĂśsung kann ein Treuhand-Vertrag helfen, der z.B. erst das Geld freigibt, wenn die
Ware eingetroffen ist. Dies ist allerdings nur der einfachste Fall. Anders sieht es vor allem bei
der Meldepflicht von bĂśrsennotierten Kontrakten wie Derivate aus. Diese mĂźssen einer
zentralen Stelle gemeldet werden. Weitere offene rechtliche Fragen, um eine Portierung von
analogen VertrĂ¤gen zu Smart Contracts zu ermĂśglichen, stehen ebenso im Raum (siehe Kapitel
2.3).
Auch ist aufgrund der jungen Entwicklung keine Standardisierung vorhanden. Die bisherigen
Plattformen verfolgen im Kern dieselbe Idee, allerdings mit Eigenimplementierungen. Im
Gegensatz zu KryptowĂ¤hrung-Plattformen hat sich noch keine Smart Contract-Plattform am
Markt etablieren kĂśnnen. Allerdings sei hier erwĂ¤hnt, dass âEthereumâ nach eigener
EinschĂ¤tzung die grĂśĂte Entwickler- und Nutzergemeinde besitzt. Auch namhafte Firmen
sehen hier ein gewisses Potential. So hat Microsoft erst kĂźrzlich die Blockchain-as-a-Service in
âAzureâ aufgenommen. Dieser Dienst basiert ebenfalls auf Ethereum (Gray, 2015).
Ein weiteres Thema ist der Schutz von VertrĂ¤gen. Smart Contracts sind auf der einen Seite in
einem gewissen MaĂe vor Manipulationen geschĂźtzt, allerdings sind jegliche vertraglichen
Vereinbarungen und Details Ăśffentlich in der Blockchain vorhanden, sodass jeder Teilnehmer
des Netzwerkes diese betrachten kann. Hier kĂśnnten mit dem Projekt âHAWKâ erste AnsĂ¤tze
zur LĂśsung des Problems angestrebt werden (Kosba, Miller, Shi, Wen, & Papamanthou, 2015).
2.3

Rechtliche Einordnung

KryptowĂ¤hrungen und Smart Contracts tangieren durch ihr Wesen eine Reihe von
gesetzlichen Regelungen. Aus diesem Grund erfolgt an dieser Stelle eine kurze rechtliche
Einordnung der KryptowĂ¤hrungen und im Besonderen der KryptowĂ¤hrung Bitcoin. Die
Einordnung bezieht sich explizit nur auf KryptowĂ¤hrungen, da zum Zeitpunkt der Ausarbeitung
keine qualitativen Aussagen zur rechtlichen Einordnung von Smart Contracts vorlagen. Die
Einordnung gliedert sich in die Punkte WĂ¤hrungsrecht, Lizenzrecht, Einkommens â und
Abgeltungssteuerrecht sowie Umsatzsteuerrecht.
WĂ¤hrungsrecht
In Deutschland ist es, nach Â§14 des Bundesbankgesetzes, nur der Deutschen Bundesbank
erlaubt Banknoten in Umlauf zu bringen. ZusĂ¤tzlich sagt Â§14, dass auf Euro lautende

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

10

Banknoten das Einzige unbeschrĂ¤nkte gesetzliche Zahlungsmittel sind. Daneben ist es nach
Â§35 verboten Geldzeichen (Marken, MĂźnzen, Scheine oder andere Urkunden, die geeignet
sind, im Zahlungsverkehr an Stelle der gesetzlich zugelassenen MĂźnzen oder Banknoten
verwendet zu werden) auszugeben oder zur Zahlung zu verwenden. (von Uhruh, 2015, S. 62)
Die Bundesanstalt fĂźr Finanzdienstleistungsaufsicht (BaFin) klassifiziert Bitcoin aber nicht als
Zahlungsmittel, sondern als Finanzinstrumente in der Form von Rechnungseinheiten gemĂ¤Ă Â§
1 Absatz 11 Satz 1 Kreditwesengesetz (KWG) (MĂźnzer, 2013) . Von daher ist davon
auszugehen, dass mit der SchĂśpfung oder Verwendung von Bitcoin kein VerstoĂ gegen das
Bundesbankgesetz vorliegt.
Lizenzrecht
Seitdem Bitcoin immer populĂ¤rer und beliebter als Zahlungsmittel wird, haben auch die
Gesetzgeber die Notwendigkeit erkannt, das Bitcoin-Systeme Ăźberwacht und reguliert werden
sollten. Plattformen die Bitcoin-Transaktionen anbieten sollten zum Schutz ihrer Nutzer gegen
Betrug und zur Verhinderung von GeldwĂ¤sche lizensiert werden. In Deutschland sind
Betreiber von Finanzdienstleistungen, nach Â§32 des Kreditwesengesetzes, dazu verpflichtet
eine Erlaubnis der AufsichtsbehĂśrde einzuholen.
KWG Â§32 (1) Wer im Inland gewerbsmĂ¤Ăig oder in einem Umfang, der einen in kaufmĂ¤nnischer
Weise

eingerichteten

GeschĂ¤ftsbetrieb

erfordert,

BankgeschĂ¤fte

betreiben

oder

Finanzdienstleistungen erbringen will, bedarf der schriftlichen Erlaubnis der AufsichtsbehĂśrde.
Damit Betreiber unter das Kreditwesengesetz fallen, genĂźgt es schon, dass sie ihre
Dienstleistungen deutschen Kunden anbieten, sie benĂśtigen keinen Sitz oder eine
Niederlassung in Deutschland. VerstĂśĂe gegen das Kreditwesengesetz werden mit Geldund/oder Freiheitsstrafen geahndet. Das Bitcoin-Plattformen unter das Kreditwesengesetz
fallen ist nicht etwa der Tatsache geschuldet, dass der deutsche Gesetzgeber besonders
schnell eine Anpassung an das Gesetz vorgenommen hat, sondern vielmehr darin, dass
deutsche Gesetze in der Regel sehr weit gefasst und abstrakt gehalten sind. (Boehm & Pesch,
2014, S. 44)
Einkommens- und Abgeltungssteuerrecht
Durch die steigende Verbreitung von Bitcoin sind auch die SteuerbehĂśrden auf die
KryptowĂ¤hrung aufmerksam geworden. Sie haben Interesse daran, dass Einkommen
rechtmĂ¤Ăig versteuert wird, welches in Form von Bitcoin erzielt wird. Deutsche
SteuerbehĂśrden klassifizieren Bitcoin als Wirtschaftsgut und diese mĂźssen daher
entsprechend versteuert werden. Dies bedeutet, dass Spekulationsgewinne, welche innerhalb
eines Jahres realisiert werden, voll versteuert werden mĂźssen. Davon ausgenommen ist ein
Freibetrag von 600 âŹ. Dies bedeutet auch, dass Spekulationsgewinne mit Bitcoin, anders als

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

11

z.B. bei Aktien, Zertifikaten oder Fonds, nicht mit 25 % Abgeltungssteuer belastet werden.
(Boehm & Pesch, 2014, S. 45)
Umsatzsteuerrecht
Anders sieht die Betrachtung bei der Umsatzsteuer aus. In Deutschland sind nach Paragraf 1
Absatz 1 UmsĂ¤tze die Lieferungen und sonstigen Leistungen, die ein Unternehmer im Inland
gegen Entgelt im Rahmen seines Unternehmens ausfĂźhrt, steuerpflichtig. Nach dieser
Betrachtungsweise, wĂ¤re z.B. der Tausch von Euro (Entgelt) gegen Bitcoin (Wirtschaftsgut)
Ăźber eine kommerzielle Plattform umsatzsteuerpflichtig. Wohingegen ein reiner
WĂ¤hrungstausch wie zum Beispiel Euro gegen britische Pfund von der Umsatzsteuerpflicht
befreit ist. Hier entschied das Bundesministerium der Finanzen aber, dass die bloĂe
Entgeltentrichtung keine Lieferung oder sonstige Leistung im Sinne des Â§1 Absatz 1 des
Umsatzsteuergesetzes ist. Dies geht aus der Antwort des Bundesministeriums der Finanzen
vom 27. September 2013 auf die Anfrage des Bundestagsabgeordneten Frank SchĂ¤ffler hervor
(Koschyk, 2013).

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

3

SEITE

12

Funktionsweise der Blockchain-Technologie

Die Blockchain-Technologie ist die Basis fĂźr alle aktuellen KryptowĂ¤hrungen und SmartContract-AnsĂ¤tze. In der Blockchain werden alle jemals in Bezug auf die KryptowĂ¤hrung
getĂ¤tigten Transaktionen gespeichert. Ziel dieses Kapitels ist es, die komplexe Funktionsweise
umfĂ¤nglich und anschaulich darzustellen.
ZunĂ¤chst werden die einzelnen Komponenten, aus denen sich die Blockchain zusammensetzt,
erlĂ¤utert. Daraufhin werden die fĂźr die Funktionsweise der Blockchain-Technologie
notwendigen kryptografischen Verfahren dargestellt. Im dritten Teil werden die vorgestellten
Komponenten in Verbindung gebracht und somit die Logik der Blockchain-Technologie
veranschaulicht.
3.1

Komponenten

Damit die in den folgenden Kapiteln beschriebenen Blockchain-Komponenten richtig
eingeordnet werden kĂśnnen, gibt dieser Abschnitt einen kurzen Ăberblick Ăźber die
verwendeten Begrifflichkeiten. In Abbildung 1 ist eine Blockchain mit ihren Komponenten
schematisch dargestellt. Eine Transaktion kann als Ăberweisung eines Geldbetrags von Person
A zu Person B gesehen werden. Diese Transaktion wird verschlĂźsselt und per Broadcast an alle
Teilnehmer des Netzwerks gesendet. Die Teilnehmer kĂśnnen zum einen die Rolle des Clients
und zum anderen auch die Rolle des Miners einnehmen (siehe Kapitel 3.3.1). Die im Netzwerk
verĂśffentlichten Transaktionen werden auf ValiditĂ¤t geprĂźft. Welche Eigenschaften eine
Transaktion erfĂźllen muss, um als valide gekennzeichnet zu sein, wird in Kapitel 3.1.1 nĂ¤her
betrachtet.
Blockchain
Genesis-Block

GĂźltiger Strang
Block

t0

t0
t1

t0
t1
t1
tn
tn

Transaktion

Abbildung 1: Ăberblick Blockchain-Komponenten

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

13

Jeder Teilnehmer in der Rolle des Miners versucht fortlaufend einen neuen validen Block zu
generieren und diesen an die aktuell gĂźltige Blockchain anzuhĂ¤ngen. Ein Block umfasst
mehrere Transaktionen und kennt seinen VorgĂ¤nger. Durch dieses Beziehungswissen entsteht
eine Kette von validen BlĂścken, die Transaktionen beinhaltet. Der erste Block dieser Kette wird
Genesis-Block genannt. Die Transaktionen bestehen aus Inputs und Outputs. Der Ouput einer
Transaktion verweist immer auf einen Ăśffentlichen SchlĂźssel. Der Teilnehmer mit dem
passenden privaten SchlĂźssel kann Ăźber den WĂ¤hrungsbetrag, der als Ziel den Ăśffentlichen
SchlĂźssel hat, verfĂźgen, indem er diesen Output als Referenz fĂźr seinen Input einer
nachfolgenden Transaktion verwendet. So ist es mĂśglich den Geldfluss Ăźber die Blockchain bis
zu ihrem Ursprung zurĂźck zu verfolgen, da jeder Input genau mit dem einem Output einer
vorherigen Transaktion verknĂźpft ist (Bitcoinwiki-C).
Jeder Teilnehmer des Netzwerks hat eine Kopie der aktuellen Blockchain gespeichert. Es kann
vorkommen, dass zwei Teilnehmer in der Rolle des Miners âgleichzeitigâ einen neuen validen
Block generieren und diesen im Netzwerk verbreiten. Somit entstehen kurzzeitig parallele
BearbeitungsstrĂ¤nge der Blockchain, die sich im Zeitverlauf wieder korrigieren. Langfristig
kann die Blockchain als konsistenter, permanenter und unverĂ¤nderbarer Speicher gesehen
werden (siehe Kapitel 4.3 mit Angriffsszenarien ). Die Blockchain nimmt damit die Rolle des
Kontobuchs einer Bank ein, indem zu einem Konto alle Transaktionen gespeichert werden
(Bitcoin.org-B).
3.1.1 Transaktion
Eine Transaktion ist eine KernfunktionalitĂ¤t eines Zahlungssystems. Sie ermĂśglicht das
Versenden und das Empfangen von Geldeinheiten. Im Gegensatz zu einer klassischen
Transaktion bei einer Bank wird hier nicht die Kontonummer des EmpfĂ¤ngers angegeben,
sondern sein Ăśffentlicher SchlĂźssel. MĂśchte jemand einen WĂ¤hrungsbetrag empfangen, muss
dieser sich ein SchlĂźsselpaar - z.B. Ăźber das RSA oder ECDSA Verfahren - generieren und den
Ăśffentlichen SchlĂźssel dem Sender mitteilen. Eine Beispiel zur SchlĂźsselgenerierung befindet
sich in Anhang E.1. Die Transaktion muss dem ACID-Prinzip entsprechen (Vossen & Weikum,
2001, S. 23 - 26):
-

Atomicity: AusfĂźhrung der Transaktion ganz oder gar nicht

-

Consistency: Wenn der Datenbestand vor der Transaktion konsistent war, muss er es
auch im Nachgang sein (Input = Output)

-

Isolation: Mehrere gleichzeitige Transaktionen dĂźrfen sich nicht beeinflussen

-

Durability: Die Transaktionen und/oder deren Auswirkungen mĂźssen dauerhaft im
System gespeichert sein und kĂśnnen nicht gelĂśscht werden

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

14

In Bezug auf die Blockchain bedeutet dies, dass eine Transaktion die Eigenschaften in einem
dezentralen System ohne zentrale Datenbank, ohne zentrale Verarbeitungslogik sowie ohne
zentrale Kontrollinstanz einhalten muss. In Abbildung 2 wird der Aufbau einer Transaktion
schematisch dargestellt.

- Transaktionshash
- Timestamp
- Version
Transaktion

- Input Transaktionshash
- Output Nr.
- Wert
- Signatur
- Input Transaktionshash
- Output Nr.
- Wert
- Signatur

Input
0

Output
0

- Zieladresse
- Wert
- Pub-Key-Hash

Input
1

Output
1

- Zieladresse
- Wert
- Pub-Key-Hash

Output
2

- Zieladresse
- Wert
- Pub-Key-Hash

Abbildung 2: Grundlegender Transaktionsaufbau

Eine Transaktion in der Blockchain besteht aus mindestens einem Input und mindestens zwei
Outputs. Die Summe der Werte von Inputs und Outputs muss gleich sein, damit eine
Transaktion gĂźltig ist. Ein Input hat immer einen direkten Bezug zu einem Output einer
Transaktion, die schon in einem validen Block enthalten ist und noch nicht als Input einer
weiteren Transaktion genutzt wurde. Aus diesen Bedingungen entsteht eine eins-zu-einsBeziehung zwischen Output einer validierten Transaktion und Input einer neuen Transaktion.
Diese Beziehung wird Ăźber den eindeutigen Transaktionshash und die Output Nr. (also Stelle
des Outputs in der Liste der Outputs der vorherigen Transaktion) hergestellt. Ăber diese
Verkettung kann eindeutig bestimmt werden, welche GeldbetrĂ¤ge zu welcher Adresse
gesendet wurden. Des Weiteren ist es nicht mĂśglich zwei valide Transaktionen zu erstellen,
die den gleichen Output einer vorherigen Transaktion verwenden. Somit ist eine doppelte
Ausgabe von GeldbetrĂ¤gen nicht mĂśglich und somit die Anforderung der âConistencyâ erfĂźllt
(Bitcoinwiki-L, 2015).
Neben den Inputs benĂśtigt eine Transaktion mindestens zwei Outputs, wobei der Output mit
der Nummer null fĂźr die TransaktionsgebĂźhren reserviert ist. Diese TransaktionsgebĂźhr wird
durch die Differenz von Inputs und Outputs gebildet und an denjenigen ausgezahlt, der den
validen Block, welcher die Transaktion beinhaltet, berechnet und an die Blockchain angehĂ¤ngt
hat (weitere Informationen hierzu befinden sich im Kapitel 3.1.2.) Jeder Output besteht aus

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

15

einer Zieladresse und einem Wert. Die Zieladresse wird aus dem Ăśffentlichen SchlĂźssel des
EmpfĂ¤ngers gebildet, vergleichbar mit einer Kontonummer des EmpfĂ¤ngers. Der Wert wird
vom Sender und/oder von der Software festgelegt. Wie genau eine Transaktion erstellt wird
ist in Kapitel 3.3.2 aufgefĂźhrt (Bitcoinwiki-L, 2015).
Damit sichergestellt ist, dass nur der Besitzer einer WĂ¤hrungseinheit Ăźber diese verfĂźgen
kann, wird eine Transaktion vom Transaktionsersteller signiert. Hierzu kann das Elliptic Curve
Digital Signature Algorithm (ECDSA) Verfahren verwendet werden (Bitcoinwiki-D, 2015). Eine
genauere Beschreibung der Funktionsweise von Digitalen Signaturen befindet sich in Kapitel
3.2.1. Die Signierung einer Transaktion wird in der Regel von der Wallet-Software
durchgefĂźhrt.
privater
SchlĂźssel

Transaktion

Ăśffentlicher
SchlĂźssel

Signierte
Transaktion

Validierte
Transaktion

Abbildung 3: Signieren und validieren einer Transaktion

Abbildung 3 zeigt den Zusammenhang von privatem und Ăśffentlichen SchlĂźssel zu einer
Transaktion. Durch die Signierung der Transaktion kann von allen Teilnehmern des Netzwerks
Ăźber den Ăśffentlichen SchlĂźssel geprĂźft werden, ob die Transaktion valide ist und somit vom
aktuellen Besitzer der WĂ¤hrungseinheiten kommt. Jeder, der Ăźber den privaten SchlĂźssel
verfĂźgt, kann Ăźber die an die entsprechende Adresse gesendeten WĂ¤hrungseinheiten
verfĂźgen. Ăhnlich wie ein Geldschein, der seinen Besitzer nicht kennt und somit von jedem,
der ihn physisch besitzt, auch ausgegeben werden kann (Nakamoto, 2009, S. 2).
Aufgrund der dezentralen Datenhaltung ist es notwendig, einen Mechanismus einzufĂźhren,
der es unmĂśglich macht den Inhalt einer Transaktion im Nachgang zu verĂ¤ndern. Zur LĂśsung
dieses Problems wird fĂźr die gesamte Transaktion ein Transaktionshash gebildet. Dieser
beinhaltet alle relevanten Informationen zu einer Transaktion. Werden im Nachgang einzelne
Parameter einer Transaktion manipuliert, verĂ¤ndert sich der Transaktionshash und die
Transaktion ist nicht mehr valide. Dieser Transaktionshash ist auch fĂźr die konsistente
Speicherung der Transaktionen in BlĂścken und somit in der Blockchain relevant (Nakamoto,
2009, S. 2).

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

16

3.1.2 Block
Ein Block stellt eine Sammlung von validen Transaktionen dar, der in der Blockchain persistent
gespeichert wird und somit nicht mehr verĂ¤ndert werden kann. In Abbildung 4 sind die
relevanten Daten, die ein Block beinhaltet, schematisch dargestellt. Jeder Block kennt seinen
VorgĂ¤nger, wodurch sich eine Kette von BlĂścken bildet. Jeder Teilnehmer in der Rolle des
Miners kann den nĂ¤chsten gĂźltigen Block erstellen und an die Blockchain anhĂ¤ngen. Hierbei
ist die RechenkapazitĂ¤t des Miners relevant, da fĂźr die Erstellung eines Blocks ein
mathematisches Problem gelĂśst werden muss. Die LĂśsung des Problems kann nur durch Trialand-Error herausgefunden werden. Das Ergebnis der Berechnung ist der gĂźltige Blockhash
(Bitcoin.org-A). Eine detaillierte Beschreibung der Generierung eines validen Blocks befindet
sich in Kapitel 3.3.3.

- Blockhash
- Zeitstempel
- Schwierigkeit
- Version
- Nonce

Block

Pre-Blockhash

Merkle Root
Hash
h1

T0

h2

T1

...

Tn

Abbildung 4: Grundlegender Blockaufbau

Welche Transaktionen in einen Block aufgenommen werden bestimmt der Miner, der den
Block generiert. Dieser hat eine lokale Liste mit verfĂźgbaren Transaktionen, die zuvor per
Broadcast an die Teilnehmer des Netzwerks gesendet wurde. Diese Liste wird nach Wert und
TransaktionsgebĂźhren sortiert. Somit werden Transaktionen mit einem hohen Wert und somit
einer groĂen TransaktionsgebĂźhr bevorzugt von den Minern berĂźcksichtigt. Die erste
Transaktion eines Blocks nennt sich Coinbase-Transaktion, da diese einen besonderen
Stellenwert hat. Bei jedem neuen Block wird eine bestimmte Anzahl an WĂ¤hrungseinheiten
an den Ersteller des Blocks (Miner) ausgezahlt. Die Menge an WĂ¤hrungseinheiten ist durch die
Software festgelegt und reduziert sich im Zeitverlauf. Die Coinbase-Transaktion hat als einzige
keinen Input und stellt somit den Ursprung der neuen WĂ¤hrungseinheiten dar. Ăber die
Blockchain kann zu einer WĂ¤hrungseinheit der komplette Transaktionsverlauf bis zur

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

17

Coinbase-Transaktion verfolgt werden. Die Transaktionshashes der berĂźcksichtigten
Transaktionen werden zu einem Hashbaum zusammengefasst. In Anhang C.1 wird die
Berechnung eines solchen Hashbaumes an einem Beispiel erklĂ¤rt. Durch dieses Verfahren
entsteht ein eindeutiger Hashwert, der alle Transaktionen des Blocks berĂźcksichtigt. Wird eine
VerĂ¤nderung an einer Transaktion vorgenommen, entsteht ein komplett anderer Hashwert
und der Blockhash ist nicht mehr valide. Somit ist sichergestellt, dass ein Block oder
Transaktionen eines Blocks nicht mehr im Nachgang verĂ¤ndert werden kĂśnnen. Neben den
Transaktionen wird auch der Bezug zum VorgĂ¤ngerblock bei der Generierung des Blockhashs
berĂźcksichtigt. Eine detaillierte Beschreibung des hier verwendeten Algorithmus (Hashcash)
befindet sich in Kapitel 3.3.3. (Bitcoinwiki-C).
Einen validen Block zu generieren ist durch die benĂśtigte mathematische Berechnung sehr
aufwĂ¤ndig, wohingegen die Validierung sehr schnell erfolgt. Diese Eigenschaft ist notwendig,
da ein erstellter Block durch die Teilnehmer des Netzwerks geprĂźft und fĂźr korrekt befunden
werden muss (Bitcoinwiki-B).
3.1.3 Dezentrales Netzwerk/Applikation
Die komplette Anwendung ist dezentral aufgebaut, was bedeutet, dass es keine zentrale
Serverinstanz gibt, die Anfragen beantwortet und fĂźr die LauffĂ¤higkeit der Software
notwendig ist. Jeder, der im Netzwerk mit der Rolle des Clients oder Miners teilnehmen
mĂśchte, benĂśtigt lediglich die entsprechende Software. Das Netzwerk basiert auf dem Peerto-Peer-Prinzip somit kommunizieren die Teilnehmer direkt miteinander. Beim erstmaligen
Anmelden am Netzwerk werden Ăźber verschiedene DNS-Server aktive Nodes des Netzwerks
ermittelt. Mit diesen Nodes werden Verbindungen erĂśffnet, um weitere Teilnehmer des
Netzwerks kennen zu lernen. Beim Erstellen einer Verbindung tauschen die Nodes ihre Liste
mit aktiven Nodes aus und ergĂ¤nzen ihre lokale Liste gegebenenfalls. Die Kommunikation
erfolgt auf der TCP-Ebene und stellt somit eine direkte Socket-Kommunikation dar (Decker &
Wattenhofer, Information Propagation in the Bitcoin Network, 2013, S. 3 - 4).
In Abbildung 5 sind die zwei Rollen (Miner und Client) dargestellt, die ein Teilnehmer im
Blockchain-Netzwerk einnehmen kann. Hierbei ist zu beachten, dass der Miner
RechenkapazitĂ¤t zur VerfĂźgung stellt, um neue BlĂścke zu generieren, mit der Intention fĂźr das
erfolgreiche Erstellen eines Blocks die neu ausgeschĂźtteten WĂ¤hrungseinheiten und die
TransaktionsgebĂźhren zu erhalten. Wohingegen der Client seine Wallet verwalten sowie
Transaktionen senden und empfangen mĂśchte. Ein Teilnehmer kann die Rolle des Miners und
die Rolle des Clients gleichzeitig einnehmen.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

Lokale Blockchain

Transaktionen empfangen
Transaktionen validieren
BlĂścke generieren
BlĂścke validieren

18

Lokale Blockchain

Miner

BlockchainNetzwerk

Client

Guthaben ermitteln
Transaktionen erzeugen
Transaktionen senden
BlĂścke empfangen
BlĂścke validieren

Abbildung 5: Rollen im Blockchain-Netzwerk

Jeder Teilnehmer im Netzwerk hat eine lokale Kopie der Blockchain, die er stĂ¤ndig mit seinen
bekannten Nodes angleicht. Des Weiteren hat jeder Teilnehmer eine lokale Liste von
bekannten Nodes im Netzwerk, die sich regelmĂ¤Ăig aktualisiert und bei Anfragen erweitert
wird. Jeder Miner hat eine lokale Liste von Transaktionen, die sich durch die eingehenden
Transaktionen der Clients erweitert. Die Liste wird als Basis fĂźr die Blockerstellung genutzt
(Bitcoinwiki-G).
Nachdem eine Verbindung mit einer Node erstellt wurde, schickt der Anfragende eine
Message mit seinem letzten bekannten Block seiner lokalen Blockchain. Dieser Block wird vom
EmpfĂ¤nger mit seinem letzten bekannten Block abgeglichen. Findet der EmpfĂ¤nger âneuereâ
BlĂścke, sendet er die Liste an NachfolgeblĂścken an den Anfragenden. Dieser holt sich alle
fehlenden BlĂścke per Anfrage an den EmpfĂ¤nger ab und fĂźgt sie seiner lokalen Liste hinzu.
Ăber diese Methodik aktualisieren die Teilnehmer des Netzwerks ihre lokale Blockchain. Im
Netzwerk verbreitet sich automatisch die âlĂ¤ngsteâ valide Blockchain, da die Nodes sich
gegenseitig nach dem letzten validen Block fragen (Bitcoinwiki-F).
Die lĂ¤ngste Blockchain wird nicht durch die Anzahl an BlĂścken bestimmt, sondern durch den
summierten Schwierigkeitsgrad. Dies ist notwendig, um ein Angriffsszenario auszuschlieĂen,
bei dem ein Angreifer eine valide Blockchain mit einem sehr niedrigen Schwierigkeitsgrad
berechnet und versucht im Netzwerk zu verbreiten (siehe Kapitel Angriffsszenarien 4.3.2).
Eine detailliertere Betrachtung des Nachrichtenaustausches zwischen zwei Teilnehmern am
Blockchain-Netzwerk wird in Anhang D.1 â D.3 anhand von Sequenzdiagrammen
veranschaulicht. In Kapitel 3.3.1 wird nĂ¤her betrachtet, wie ein Teilnehmer sich innerhalb
einer Rolle mit dem Blockchain-Netzwerk verbinden und seine Rolle ausfĂźhren kann
(Bitcoinwiki-H).
3.2

Grundlage die Kryptografie

Ein wesentlicher Bestandteil der Funktionsweise der Blockchain-Technologie sind die
verwendeten Kryptografie Verfahren. Zum einen werden digitale Signaturen verwendet um
sicherzustellen, dass Transaktionen vom korrekten Absender stammen. Zum anderen
kommen verschiedene Hashfunktionen zum Einsatz, um Daten vor nachtrĂ¤glicher
VerĂ¤nderung zu schĂźtzen.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

19

3.2.1 Digitale Signaturen
Eine digitale Signatur ist eine schlĂźsselabhĂ¤ngige PrĂźfsumme. Diese PrĂźfsumme in
Kombination mit einem Dokument (in diesem Fall einer Transaktion) weist Ă¤hnliche
Eigenschaften auf wie eine Unterschrift (Schmeh, 2013, S. 202):
-

FĂ¤lschungssicher

-

PrĂźfbarkeit der Echtheit

-

Keine Ăbertragbarkeit zu einem anderen Dokument

-

Keine unbemerkte VerĂ¤nderung des Dokuments

Abbildung 6 illustriert die digitale Signatur am Beispiel einer Transaktion. FĂźr eine digitale
Signatur wird ein SchlĂźsselpaar bestehend aus einem privaten und einem Ăśffentlichen
SchlĂźssel benĂśtigt. Der private SchlĂźssel in Kombination mit dem zu signierenden Urbild (hier
die Transaktion) ergibt die digitale Signatur. Mit Hilfe des Ăśffentlichen SchlĂźssels kann ein
Dritter prĂźfen, ob das Urbild verĂ¤ndert wurde. Wie die Erstellung eines SchlĂźsselpaares und
die anschlieĂende PrĂźfung vom Prinzip funktioniert wird in Anhang E.1 an einem Beispiel
gezeigt (Schmeh, 2013, S. 202).
privater
SchlĂźssel

Ăśffentlicher
SchlĂźssel

PrĂźfung
#34AB12..

Ja
X Nein

Digitale
Signatur

Transaktion

Verifikation

Abbildung 6: Digitale Signatur am Beispiel - Transaktion

Als Verfahren zum Signieren von Transaktionen kĂśnnen zum einen asymmetrische
VerschlĂźsselungsverfahren (wie z.B. RSA) zum anderen Signaturverfahren auf Basis des
diskreten Logarithmus (wie z.B. DAS) verwendet werden. Im Fall von Bitcoin wird hierzu die
Abwandlung ECDSA eingesetzt. Diese Abwandlung basiert auf elliptischen Kurven und
ermĂśglicht eine kĂźrzere SchlĂźssellĂ¤nge bei gleicher Sicherheit (Schmeh, 2013, S. 216).
3.2.2 Kryptografische Hashfunktionen
Hashfunktionen dienen dazu die PrĂźfsumme fĂźr ein Urbild zu erstellen. Das Urbild wird im Fall
der Blockchain-Technologie entweder aus Teilen einer Transaktion oder aus Teilen eines
Blocks zusammengesetzt. Bei einer Transaktion wird das Urbild aus den Input(Transaktionshash der vorherigen Transaktion, Wert, Signatur usw.) sowie aus den OutputDaten (Adresse, Wert usw.) gebildet. Sobald eine Ănderung an einem Parameter innerhalb
der Transaktion durchgefĂźhrt wird, Ă¤ndert sich der Transaktionshash.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

20

Die verwendeten Hashfunktionen sichern die BlĂścke und Transaktionen einer Blockchain vor
nachtrĂ¤glicher VerĂ¤nderung. Da die Daten fĂźr jeden im Netzwerk transparent vorliegen, kann
auch jeder Teilnehmer die GĂźltigkeit der Hashwerte validieren.
Transaktionshash

SHA-256

Transaktion

RIPEMD-160
#34AB12..

#517CDA..

Hashwert
256 Bit

Hashwert
160 Bit

Abbildung 7: Kryptografische Hashfunktion am Beispiel - Transaktion

Aktuell werden die Verfahren SHA-2, SHA-3 und RIPEMD-160 zur Generierung der Hashwerte
eingesetzt. Im Fall von Bitcoin wird doppelt gehasht. Wie Abbildung 7 zeigt, werden die Daten
zunĂ¤chst mittels SHA-256 gehasht, worauf der entstehende Hashwert wiederum mittels
RIPEMD-160 oder SHA-256 gehasht wird. Ziel dieser doppelten Bearbeitung der Daten ist zum
einen der kĂźrzere Hashwert und zum anderen die erhĂśhte Sicherheit gegen Angriffe. In
Anhang E.2 wird das Prinzip von SHA256 anhand eines Schaubilds verdeutlicht.
Es werden grundsĂ¤tzlich zwei Abstufungen bei den Angriffen auf kryptografische
Hashfunktionen unterschieden. Die Suche nach Kollisionen ist die Erste. Hierbei wird versucht
zwei beliebige Urbilder zu finden, welche den gleiche Hashwert ergeben. Dies wird als Kollision
bezeichnet. Das zweite Angriffsszenario ist die Suche nach einem zweiten Urbild, wobei ein
Urbild oder der Hashwert vorgegeben ist. Im Folgenden werden mĂśgliche Angriffsszenarien
aufgefĂźhrt und in Zusammenhang mit der Blockchain-Technologie gebracht (Schmeh, 2013, S.
228-236):
-

Substitutionsattacke: Der Angreifer fĂ¤ngt in diesem Fall die Nachricht inkl.
zugehĂśrigem Hashwert ab und versucht durch Ersetzen von WĂśrtern eine Nachricht zu
generieren, die den gleichen Hashwert erzeugt. Je lĂ¤nger in diesem Fall der Hashwert
ist, umso mehr MĂśglichkeiten muss der Angreifer ausprobieren. Bei einer
HashwertlĂ¤nge von RIPEDM mit einem Wert von 160 Bit mĂźsste der Angreifer 160
ErsetzungsmĂśglichkeiten finden und daraus 2160 Hashwerte bilden.

-

Geburtstagsangriff: Umfasst der Hashwert eine LĂ¤nge von 128 Bit gibt es 2128
mĂśgliche Hashwerte. Das Geburtstagsproblem besagt, dass der Angreifer im
Durchschnitt nur 2128/2 = 264 Versuche benĂśtigt, um eine Kollision zu finden. Aus
diesem Grund benutzen alle neueren Hashverfahren und auch die aktuellen
KryptowĂ¤hrungen mindestens eine Bit LĂ¤nge von 160.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS
-

SEITE

21

WĂśrterbuch-Angriff: Der WĂśrterbuchangriff nutzt die Tatsache aus, dass z.B.
Computersysteme von PasswĂśrtern nur den zugehĂśrigen Hashwert speichern. Somit
ist es mĂśglich, mit Hilfe einer entsprechenden Tabelle, die WĂśrter mit ihrem
zugehĂśrigen Hashwert enthĂ¤lt, die Hashwerte zu vergleichen. Wird der gleiche
Hashwert gefunden weiĂ der Angreifer das dazu gehĂśrige Passwort. Dieser Angriff
macht in Bezug auf die Blockchain keinen Sinn, da das Urbild (Transaktionen oder
BlĂścke) Ăśffentlich zugĂ¤nglich sind.

-

Regenbogentabellen: Die kryptografischen Hashfunktionen haben die Eigenschaft,
dass diese bei einem gleichen Urbild auch immer den gleichen Hashwert erzeugen.
Anders als bei VerschlĂźsselungsverfahren wird kein SchlĂźssel zur Generierung des
Hashwertes verwendet. Somit kann die erfolgreiche Suche nach einer Kollision nicht
durch einen SchlĂźsselwechsel wieder zunichte gemacht werden. Hieraus ergibt sich die
MĂśglichkeit, alle erfolgreichen Angriffe als Urbild-Hashwert-Paar in einer Tabelle zu
speichern. Diese Tabelle kann genutzt werden, um zu einem Hashwert das passende
Urbild zu finden. Der Vergleich von Hashwerten ist deutlich performanter als die
Berechnung. Jedoch benĂśtigt eine solche Tabelle viel Speicherplatz.

Diese Beispiele verdeutlichen die AngriffsmĂśglichkeiten auf kryptografische Hashfunktionen.
Im Gegensatz zu symmetrischen oder asymmetrischen VerschlĂźsselungsverfahren kann
einem Angriff hierbei nur mit einem lĂ¤ngeren Hashwert begegnet werden. Die aktuellen
Hashverfahren verwenden eine HashwertlĂ¤nge zwischen 160 und 512 Bit. Mit grĂśĂerer
HashwertlĂ¤nge steigt jedoch auch der Aufwand bei der Berechnung. Somit erzeugt die
HashwertlĂ¤nge immer ein Trade-off zwischen Aufwand und Sicherheit (Schmeh, 2013, S. 228
- 236).
3.3

Von der Transaktion zum validierten Block

In den Kapiteln 3.1 und 3.2 wurden die Komponenten der Blockchain-Technologie und der
Zusammenhang mit der Kryptografie veranschaulicht. Im folgenden Kapitel wird der Prozess
von der anfĂ¤nglichen Verbindung mit dem Blockchain-Netzwerk Ăźber die Erstellung und
VerĂśffentlichung einer Transaktion bis zum generierten Block behandelt.
3.3.1 Verbinden mit dem Blockchain-Netzwerk
FĂźr die Erstellung von Transaktionen fĂźr ein Blockchain-Netzwerk muss sich der Teilnehmer
zunĂ¤chst mit dem Netzwerk verbinden. FĂźr diesen Zweck gibt es eine dezentrale Software, die
jeder Teilnehmer lokal installieren muss. Diese Software stellt die Verbindung zum Netzwerk
her und holt sich die benĂśtigten Informationen wie zum Beispiel den aktuellen Stand der
Blockchain, Adressen weiterer Nodes oder auch von anderen Teilnehmern gesendete

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

22

Transaktionen (nur fĂźr das Mining relevant). Diese Software liefert die BasisfunktionalitĂ¤ten,
um sich aktiv am Netzwerk zu beteiligen und wird daher auch Core genannt (Bitcoinwiki-A).
Je nach Rolle, die ein Teilnehmer ausfĂźhren mĂśchte, wird von diversen Anbietern WalletSoftware oder Mining-Software angeboten. Die Wallet-Software stellt die GeldbĂśrse oder das
Konto des Clients dar. Der Unterschied zu einem Bankkonto liegt darin, dass keine
GeldbetrĂ¤ge, sondern SchlĂźsselpaare gespeichert werden. Auf Basis dieser SchlĂźsselpaare
kann die Wallet-Software ein Guthaben aus der Summe der eingehenden Transaktionen
bilden. Hierzu nutzt die Wallet Software die BasisfunktionalitĂ¤ten der Core-Software, um die
gesamte Blockchain nach diesen Transaktionen zu durchsuchen. Dieses Vorgehen ist mĂśglich,
da die komplette Blockchain Ăśffentlich zugĂ¤nglich ist und somit von jedem gelesen werden
kann. Neben der Anzeige des aktuell verfĂźgbaren Guthabens ist die Wallet-Software fĂźr das
Erzeugen von SchlĂźsselpaaren als Adresse fĂźr eingehende Transaktionen sowie das Erstellen
und Versenden von Transaktionen zustĂ¤ndig. Eine detaillierte Betrachtung zur Erstellung von
Transaktionen befindet sich in Kapitel 3.3.2 (Bitcoin.org).
Es gibt unterschiedliche Arten von Wallets, die sich in ihrer Sicherheit und Funktionsweise
unterscheiden. Zu den Funktionen einer Wallet zĂ¤hlen die Generierung eines privaten
SchlĂźssels, das Ableiten eines Ăśffentlichen SchlĂźssels, das Versenden des Ăśffentlichen
SchlĂźssels, das Ăberwachen der Outputs, das Erstellen von Transaktionen, das Signieren von
Transaktionen und das Versenden von Transaktionen. Im Folgenden werden die einzelnen
Arten von Wallets kurz aufgefĂźhrt (Bitcoin.org):
-

Full-Service Wallet: Bietet alle Funktionen auf einem GerĂ¤t und ist mit dem Netzwerk
verbunden (Online-Wallet)

-

Signing-Only Wallet: Die Signing-Only Wallet Ăźbernimmt die Erstellung des privaten
SchlĂźssels und die Signierung von Transaktionen. Sie ist nicht mit dem Netzwerk
verbunden (Offline Wallet) und arbeitet mit einer Online Wallet zusammen. Diese
Trennung erhĂśht die Sicherheit. Eine mĂśgliche Erweiterung stellt eine Hardware
Wallet dar, die an eine spezielle Hardware gebunden ist und ebenfalls eine erhĂśhte
Sicherheit bietet.

-

Distributing-Only Wallet: Diese Wallet ist gemacht, um auf schwer zu schĂźtzenden
Umgebungen (wie z.B. Webserver) zu laufen. Die Wallet ist so konfiguriert, dass nur
die Weitergabe von Ăśffentlichen SchlĂźsseln erlaubt ist.

Je nach Einsatzgebiet und Sicherheitsanspruch kommen unterschiedliche Wallet-Formen
infrage. Alle Wallets speichern die erstellten, privaten SchlĂźssel in einer verschlĂźsselten Datei
(Bitcoin.org).
MĂśchte ein Teilnehmer die Rolle des Miners einnehmen und seine RechenkapazitĂ¤t fĂźr das
Erstellen und Validieren von BlĂścken nutzen, wird eine Mining-Software benĂśtigt. Auch diese

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

23

Software greift auf die FunktionalitĂ¤ten der Core-Software zurĂźck, um Informationen aus dem
Netzwerk zu empfangen und Daten an das Netzwerk zu senden. Der Miner hat die Aufgabe
eingehende Transaktionen auf ValiditĂ¤t zu prĂźfen und diese in einem Block
zusammenzufassen. Zu diesem erstellten Block muss ein Blockhash berechnet werden, damit
dieser Block der Blockchain angehĂ¤ngt werden kann. Der Miner benĂśtigt fĂźr das Erstellen
eines Blocks RechenkapazitĂ¤t und wird dafĂźr mit WĂ¤hrungseinheiten belohnt. Diese
WĂ¤hrungseinheiten setzen sich aus den summierten TransaktionsgebĂźhren der im Block
enthaltenen Transaktionen und einer von der Software festgelegten AusschĂźttung neuer
WĂ¤hrungseinheiten zusammen (siehe Coinbase-Transaktion in Kapitel 3.1.2). Eine detaillierte
Beschreibung des Algorithmus zum Erstellen eines Blocks wird in Kapitel 3.3.3 aufgefĂźhrt
(Bitcoinwiki-G).
In den AnfĂ¤ngen der KryptowĂ¤hrungen wurde primĂ¤r Solo-Mining betrieben, bei dem jeder
Teilnehmer alleine versuchte mit seiner RechenkapazitĂ¤t einen Block zu generieren. Mit
steigender Nutzeranzahl und somit auch steigender RechenkapazitĂ¤t wurde es fĂźr den
einzelnen Nutzer bei gleicher RechenkapazitĂ¤t immer unwahrscheinlicher einen validen Block
als Erster zu erstellen. Aus diesem Grund bildeten sich Mining-Pools, in denen sich Nutzer mit
ihrer RechenkapazitĂ¤t zusammen schlieĂen, um die Chance, einen validen Block zu erstellen,
zu erhĂśhen (Bitcoinwiki-G).
3.3.2 Erstellung und publizieren einer Transaktion
MĂśchte ein Teilnehmer einem anderen Teilnehmer einen WĂ¤hrungsbetrag senden oder von
einem anderen Teilnehmer einen WĂ¤hrungsbetrag empfangen, mĂźssen beide Parteien als
Client mit dem Blockchain-Netzwerk verbunden sein. Der EmpfĂ¤nger generiert z.B. mit dem
ECDSA-Verfahren eine Kombination aus Ăśffentlichem und privatem SchlĂźssel. Der Ăśffentliche
SchlĂźssel wird mittels kryptografischer Hashfunktion (z.B. RIPEMD-160) gehasht. Die
entstehende Zeichenfolge hat die Funktion einer Kontonummer. Der Sender bekommt vom
EmpfĂ¤nger den gehashten Ăśffentlichen SchlĂźssel und erstellt eine Transaktion mit der
Zeichenfolge als Zieladresse. Neben der Zieladresse und dem Betrag, der gesendet werden
soll, wird noch die entsprechende TransaktionsgebĂźhr hinterlegt. Daraufhin ermittelt die
Software den benĂśtigten Gesamtbetrag und prĂźft, ob genĂźgend eingehende Transaktionen
zur VerfĂźgung stehen, um den Betrag zu decken. Ist diese PrĂźfung erfolgreich, ordnet die
Software der Transaktion entsprechend viele Inputs zu. Wie bereits zuvor erwĂ¤hnt, kann ein
Output einer Transaktion immer nur eine 1:1 Beziehung zu einem Input einer neuen
Transaktion haben. Ein Output kann somit nicht auf zwei Transaktionen aufgeteilt werden.
Diese Beziehung zwischen Input und Output verschiedener Transaktionen wird in Anhang B.1
an einem Beispiel verdeutlicht (Bitcoinwiki-I).

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

Transaktion X

Transaktion Y

Output
0

Transaction No., Index
Input

Value:
PubKeyHash:
ScriptPubKey:

24

3
#ABC
OP_DUP OP_HASH160 #ABC OP_EQUALVERIFY OP_CHECKSIG

Previous tx:
Index:
Sig:
PubKey:
scriptSig:

X
0
#1000
#2000
#1000#2000

Abbildung 8: VerknĂźpfung von Input und Output zweier Transaktionen

Abbildung 8 zeigt die VerknĂźpfung zwischen dem Input einer Transaktion Y zu dem Output
einer vorherigen Transaktion X. In diesem Beispiel ist der Wert des Outputs von Transaktion X
an die Zieladresse â#ABCâ gesendet worden. Der Besitzer des passenden privaten SchlĂźssels
kann eine Transaktion erstellen, die einen Input hat, der auf den Output der vorherigen
Transaktion X verweist. Nur mit dem passenden privaten SchlĂźssel kann die fĂźr den Input
benĂśtigte Signatur (in diesem Beispiel #1000) erstellt werden. Wie andere Teilnehmer des
Netzwerks die GĂźltigkeit der Signatur prĂźfen kĂśnnen, wird in Anhang B.2 weiter ausgefĂźhrt
(Bitcoinwiki-I).
- Tx.: #1239244AD234C ..
- Timestamp: ...
- From: #10000
Transaktion

Wert: 3

Input
0

Wert: 10

Input
1

Output
0

- EmpfĂ¤nger: ...
- Wert: 0,1

Output
1

- EmpfĂ¤nger: #20000
- Wert: 11

Output
2

- EmpfĂ¤nger: #10000
- Wert: 1,9

Abbildung 9: Transaktion - Beispiel Input/Output-Verteilung

In Abbildung 9 wird ersichtlich, wie die zuvor beschriebene 1:1-Beziehung von Input und
Output die aktuelle Transaktion beeinflusst. MĂśchte der Teilnehmer #10000 dem Teilnehmer
#20000 einen Betrag von 11 WĂ¤hrungseinheiten senden, prĂźft die Software, ob genĂźgend
Inputs vorhanden sind, um auf den Betrag von 11 Einheiten plus 0,1 Einheiten
TransaktionsgebĂźhren zu kommen. In diesem Beispiel wurden zwei mĂśgliche Inputs mit den
Werten 3 und 10 gefunden. Die mĂśglichen Inputs kĂśnnen jedoch nicht nur zum Teil genutzt
werden, da sonst eine 1:n-Beziehung zwischen Input und Output entstehen wĂźrde. Somit

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

25

entsteht eine Differenz vom benĂśtigten Betrag (11,1 Einheiten) zu einem summierten Input
(13 Einheiten). In diesem Fall wird der Transaktion ein weiterer Output mit dem offenen
Betrag und der eigenen Zieladresse hinzugefĂźgt. Der Teilnehmer #10000 kann Ăźber den
Restwert von 1,9 Einheiten verfĂźgen, wohingegen der EmpfĂ¤nger #20000 Ăźber die an ihn
gesendeten 11 WĂ¤hrungseinheiten verfĂźgen kann (Bitcoinwiki-L, 2015).
Damit die Transaktion im Nachgang nicht verĂ¤ndert werden kann, wird fĂźr die Parameter einer
Transaktion ein eindeutiger Transaktionshash generiert. In Anhang B.3 wird anhand einer
realen Transaktion des Bitcoin-Netzwerks die Erstellung des Transaktionshashs nachvollzogen.
Die gesamte Transaktion wird vom Ersteller per Broadcast an alle ihm bekannten Nodes
gesendet. Diese Nodes nehmen die Transaktion (falls noch nicht vorhanden) in ihre Liste noch
offener Transaktionen auf und versenden diese wiederum an alle ihnen bekannten Nodes
weiter. Durch diesen Verteilungsmechanismus ist sichergestellt, dass die Transaktion im
Netzwerk bekannt ist und somit in einen der nĂ¤chsten BlĂścke aufgenommen wird. Das
Versenden und Empfangen von Transaktionen wird in Anhang D.3 anhand eines
Sequenzdiagramms veranschaulicht.
3.3.3 Blockgenerierung und Validierung
In Kapitel 3.1.2 wurde der grundlegende Aufbau eines Blocks definiert. Im Folgenden wird die
Erstellung eines validen Blocks nĂ¤her betrachtet. Die Blockerstellung ist Aufgabe der Miner,
die im Netzwerk angemeldet sind. Das Prinzip des mathematischen Problems wurde 1997 von
Adam Back entwickelt und ist unter dem Namen Hashcash-Algorithmus bekannt. Das Prinzip
wurde ursprĂźnglich zur Reduzierung von Spam-Mails entwickelt. Der Sender einer Mail muss
zunĂ¤chst RechenkapazitĂ¤t einsetzen, um einen Hashwert passend zu seiner Mail zu
berechnen. Das Erstellen eines solchen Hashwertes benĂśtigt mehrere DurchlĂ¤ufe des
Algorithmus wohingegen die PrĂźfung mit nur einer Berechnung durchgefĂźhrt werden kann.
Somit mĂźsste ein Sender von Massenmails auch einen entsprechend hohen Rechenaufwand
fĂźr das Erstellen dieser Mails aufbringen, wohingegen der EmpfĂ¤nger nur einen geringen
Aufwand bei der PrĂźfung hat (Back, 2002).
In Bezug auf die Blockgenerierung wurde dieses Prinzip Ăźbernommen und angepasst. Jeder
Miner stellt sich auf Basis seiner Transaktionsliste einen Block zusammen und versucht zu
diesem Block den passenden Blockhash Ăźber den Hashcash-Algorithmus zu finden. Dieses
Verfahren wir auch Proof-of-Work genannt (Bitcoinwiki-E).
In Abbildung 10 sind die Parameter aufgefĂźhrt, die fĂźr den Hashcash-Algorithmus benĂśtigt
werden. Der Service String setzt sich aus den relevanten Blockdaten wie z.B. dem VorgĂ¤nger
Blockhash, dem Roothash des Transaktionsbaums, dem aktuellen Schwierigkeitsgrad, einem
Zeitstempel und der Versionsnummer zusammen. Dieser Service String umfasst alle Daten,

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

26

sodass der Block nicht im Nachgang geĂ¤ndert werden kann ohne einen neuen Proof-of-Work
zu finden. Die variablen Teile der Zeichenkette sind die Nonce und der Counter, die jeweils
durch einen 32-Bit Integer Wert reprĂ¤sentiert werden. Die Nonce wird bei jedem Durchlauf
des Algorithmus erhĂśht. Ist die Nonce bei ihrem Maximum (32 Bit = 2.147.483.647)
angekommen, startet sie wieder bei null und der Counter wird hochgezĂ¤hlt. Der Counter wird
als Nachricht in der Coinbase-Transaktion eingetragen, was zur Folge hat, dass der Merkle
Root neu berechnet werden muss (Bitcoinwiki-E).
- 32-Bit Integer
- Wird nach jedem Durchgang erhĂśht
Block hashing algorithm:

Service String

Nonce

- Versionsfeld
- VorgĂ¤nger Blockhash
- Merkle Root
- Zeitstempel
- Schwierigkeit

Counter

- 32 Bit Integer
- ErhĂśht wenn Nonce auf maximum
- Gespeichert in ScriptSig des Inputs
der Coinbase Transaction

Abbildung 10: Block hashing Algorithmus â Hashcash

Die auf Basis der Parameter entstehende Zeichenfolge wird im Fall von Bitcoin doppelt mit
dem kryptografischen Hashverfahren SHA256 gehasht. Der sich ergebende Hashwert muss
mit einer, dem Schwierigkeitsgrad entsprechenden, Menge von Nullstellen beginnen. Der
Schwierigkeitsgrad wird von der Software in regelmĂ¤Ăigen AbstĂ¤nden an die im Netzwerk
verfĂźgbare RechenkapazitĂ¤t angepasst. In Anhang C.2 wird eine solche Berechnung an einem
Beispiel verdeutlicht. WeiterfĂźhrende Informationen bezĂźglich des Hashcash-Algorithmus
werden in Anhang C.3 aufgefĂźhrt (Bitcoinwiki-K).
Hat ein Miner einen validen Blockhash zu seinem Block gefunden, publiziert er diesen per
Broadcast im Netzwerk. Die Nodes im Netzwerk prĂźfen den Block und seinen Blockhash und
hĂ¤ngen diesen an ihre lokale Blockchain (sofern alle Parameter stimmen). Ein Beispiel zur
PrĂźfung des Blockhashs anhand eines realen Blocks der Bitcoin Blockchain ist in Anhang C.4
aufgefĂźhrt. Da jeder Miner an seiner lokalen Blockchain arbeitet, kann es vorkommen, dass
ein Miner einen validen Block nicht empfĂ¤ngt. Ist dies der Fall, hebt sich der Fehler spĂ¤testens
beim nĂ¤chsten validen Block, den der Miner bekommt, wieder auf. Um die VerĂ¤nderung der
lokalen Blockchain zu verdeutlichen, wurde ein Schaubild erstellt, welches den Prozess der
Blockgenerierung anhand von drei Minern beispielhaft veranschaulicht. Dieses Schaubild
befindet sich in Anhang C.5. Stellt der Miner fest, dass ihm ein Block in seiner Kette fehlt,
fordert er diesen VorgĂ¤ngerblock vom Sender des neuen Blocks an.
Jeder Miner im Netzwerk hat somit abhĂ¤ngig von seiner Rechenleistung die Chance einen
neuen Block als Erster zu generieren. Hieraus stellt sich die Frage, welche Nutzen der Miner

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

27

davon hat seine Rechenleistung fĂźr das Netzwerk zur VerfĂźgung zu stellen. Die Antwort ergibt
sich aus der Belohnung fĂźr das Erstellen von BlĂścken. Von der Software werden pro erstelltem
Block eine bestimmte Anzahl an WĂ¤hrungseinheiten neu ausgeschĂźttet. Diese Transaktion,
die standardmĂ¤Ăig immer die erste Transaktion eines neuen Blocks ist, beinhaltet neben den
neu ausgeschĂźtteten WĂ¤hrungseinheiten auch alle TransaktionsgebĂźhren der Transaktionen,
die im erstellten Block vorhanden sind. Daher kommt auch die Motivation Transaktionen mit
einer hĂśheren TransaktionsgebĂźhr bevorzug zu behandeln. Da in jedem Durchgang nur ein
Block der erste valide Block sein kann, ist hier das Angriffspotenzial groĂ, da jeder Miner die
entsprechenden WĂ¤hrungseinheiten fĂźr sich beanspruchen mĂśchte (Bitcoinwiki-G). Eine
detaillierte AusfĂźhrung mĂśglicher Angriffsszenarien auf die Blockchain werden in Kapitel 4.3
nĂ¤her betrachtet.
3.4

Kritische Reflexion

Die Blockchain bietet die MĂśglichkeit ein globales, digitales Zahlungssystem aufzubauen,
welches nicht auf Vertrauen in eine dritte Instanz beruht. Durch den Einsatz von digitalen
Signaturen kann nur der EigentĂźmer der WĂ¤hrungseinheiten diese auch ausgeben. Das
Problem der Doppelausgabe wird durch die VerknĂźpfung der Transaktionen und die
Ăśffentliche Blockchain, die durch das gesamte Netzwerk validiert wird, gelĂśst. Die Blockchain
kann bei einer entsprechenden Nutzeranzahl und RechenkapazitĂ¤t des Netzwerks nicht mehr
durch eine einzelne Partei geĂ¤ndert werden. Jeder Nutzer kann dem Netzwerk problemlos
beitreten und es wieder verlassen. Somit stellt sich also die Frage, welche EinschrĂ¤nkungen
bringt diese Technologie mit sich?
Zum einen gibt es technische Begrenzungen der aktuellen Blockchain-Technologie wie sie z.B.
im Bitcoin eingesetzt wird. Hierbei ist das aktuelle Maximum an Transaktionen die pro
Sekunde bearbeitet werden kĂśnnen, auf 7 begrenzt. Zum Vergleich verarbeitet VISA aktuell
ca. 2000 Transaktionen pro Sekunde (Swan, 2015, S. 83). Eine weitere technische HĂźrde stellt
die aktuelle Blockgenerierungsrate von einem Block pro 10 Minuten dar. Hierdurch kann es
sein, dass der Nutzer 10 Minuten warten muss bis seine Transaktion bestĂ¤tigt wird. Um sicher
zu gehen, dass die Transaktion unverĂ¤nderbar in der Blockchain gespeichert wurde, sollte der
Nutzer 3-4 BlĂścke abwarten, was eine Wartezeit von ca. 40 Minuten zur Folge hĂ¤tte. Des
Weiteren muss sich jeder Teilnehmer am Netzwerk eine lokale Kopie der Blockchain laden.
Die Blockchain hat aktuell eine GrĂśĂe von ca. 54 GB und wĂ¤chst Pro Jahr um ca. 14 GB
(Blockchaincenter, 2016). Um eine Wallet bei sich zu installieren, muss somit eine enorme
Datenmenge initial geladen werden.
Neben den technischen Restriktionen ist auch die Sicherheit ein entscheidender Faktor. Es
gibt Angriffsszenarien (wie z.B. 51 %-Attacke) die es mĂśglich machen, dass Ănderungen an der
Blockchain vorgenommen werden. Des Weiteren ist es auch mĂśglich, dass aktuell genutzte

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

28

Kryptografieverfahren geknackt werden und diese somit keine Sicherheit mehr bieten.
Daneben ist die Berechnung des Proof-of-Work ein enormer Rechenaufwand, der keinen
sinnvollen Nutzen auĂer dem Erhalt der Sicherheit im Netzwerk hat (O'Dwyer & Malone,
2014). Zuletzt soll auch die AnonymitĂ¤t des Nutzers nicht auĂer Acht gelassen werden. Durch
die Ăśffentliche Blockchain kann theoretische jede Zahlung eingesehen und zurĂźckverfolgt
werden. Sobald zu einem Ăśffentlichen SchlĂźssel die dahinterstehende Person bekannt ist,
kĂśnnen alle ZahlungseingĂ¤nge und -ausgĂ¤nge ermittelt werden. Der Nutzer kann dieser
Problematik durch das Verwenden neuer SchlĂźssel fĂźr jede Zahlung entgegenwirken (Swan,
2015, S. 83 - 87). Das Thema Sicherheit der Blockchain wird in Kapitel 4.3 nĂ¤her betrachtet.
Neben der Verwendung als Basis fĂźr ein digitales Zahlungsmittel kann die Blockchain fĂźr
diverse weitere Anwendungsszenarien eingesetzt werden. Ein Beispiel hierfĂźr sind Smart
Contracts, die ab Kapitel 2.2 nĂ¤her betrachtet wurden.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

4

SEITE

29

Prototypische Implementierung einer Blockchain

Definition und grundlegende Funktionsweisen der Blockchain-Technologie wurden im Kapitel
3 dargestellt und nĂ¤her erlĂ¤utert. Darauf aufbauend beschĂ¤ftigt sich das folgende Kapitel mit
den Herausforderungen einer Blockchain-Implementation. Zudem erfolgt auf der einen Seite
eine Bewertung der allgemeinen Blockchain-Sicherheit, wobei auch alternative Proof-ofKonzepte vorgestellt werden. Auf der anderen Seite wird ein Angriff auf den fertigen Prototyp
demonstriert.
4.1

Funktionale und nicht-funktionale Anforderungen an die Implementation

Der Prototyp soll primĂ¤r der Darstellung der Herausforderungen einer BlockchainImplementation dienen. Daher zielen seine funktionalen Anforderungen auf den Aufbau einer
rudimentĂ¤ren Blockchain. Seine nicht-funktionalen Anforderungen wiederum auf Test- und
NutzungsmĂśglichkeiten eben dieser.
Funktionale Anforderungen
-

Ein Miner muss in der Lage sein eine Blockchain zu erstellen und weiter zu fĂźhren.

-

Er muss Transaktionen und fremde BlĂścke entgegennehmen und verarbeiten.

-

Er muss fertige BlĂścke seinerseits an das Netzwerk verteilen.

-

Er muss inkonsistente/manipulierte Daten innerhalb der Blockchain erkennen.

-

Er muss sich im Netzwerk bekannt machen kĂśnnen.

Nicht funktionale Anforderungen

4.2

-

Ein Nutzer soll die MĂśglichkeit haben Transaktionen zu senden.

-

Ein Nutzer soll KontostĂ¤nde/die auf ihn gerichteten Transaktionen einsehen kĂśnnen.
Bestandteile einer Blockchain-Implementation

Die Sichtweise auf die Blockchain wandert im Rahmen eines Entwurfs von der erstmaligen
Analyse der einzelnen Bestandteile weg, hin zur Planung einer dezentralen Applikation und
der damit verbundenen Kommunikation und Synchronisation der gemeinsamen und
gleichsam redundant verteilten Blockkette. Im Folgenden werden die Entwicklungs- und
Testumgebung sowie Bestandteile und Funktionen des Prototyps vorgestellt.
4.2.1 Entwicklungs- und Testumgebung
Die Entwicklungsumgebung samt der genutzten Java-Bibliotheken ist gemĂ¤Ă Anhang F Tabelle
5 aufgebaut. Als Testumgebung dienen verschiedene teils virtuelle Computer, wobei auf allen
Testrechnern Microsoft Windows7, Windows8 oder Windows10 installiert ist. Als Netzwerk
dient ein Heimnetzwerk unter Verwendung einer Fritzbox 7490.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

30

4.2.2 Programmaufbau
Der grundlegende Aufbau sieht gemĂ¤Ă Anhang G Abbildung 34 fĂźnf Bereiche vor:
1. Eine lokale Persistenz Schicht, in der die Blockchain und die Konfigurationsparameter
im JSON-Format geschrieben/ausgelesen werden. Als Konfigurationsparameter
werden eigene Adressinformationen und auch die anderer Miner hinterlegt.
2. Eine Blockgenerierungseinheit, die kontinuierlich zwischengespeicherte Transaktionen
in BlĂścke einarbeitet und diese mittels Proof-of-Work finalisiert.
3. Eine Handshake-Einheit, die fĂźr die Bekanntmachung im Netzwerk zustĂ¤ndig ist.
4. Eine Datenversendungseinheit, die fertige BlĂścke an andere Teilnehmer leitet und ggf.
auf âRĂźckfragenâ antwortet.
5. Eine DatenempfĂ¤ngereinheit, die Transaktionen und BlĂścke anderer Miner
entgegennimmt und auswertet.
Eine Steuerungsklasse initialisiert alle fĂźnf Bereiche und stellt wĂ¤hrend des Programmablaufs
allen Klassen Konfigurations- und Objektparameter zur VerfĂźgung.
4.2.3 Grundelemente
Die Basiselemente der prototypischen Blockchain entsprechen grundlegend dem Aufbau der
Bitcoin Blockchain-Architektur (Siehe Kapitel 3.1) und sind auf Abbildung 11 zu sehen.
1..*

Chain

0..*
0..1

List<Block> blockchain

Transaction

Block
List<Transaction>
transactions

1..*
0..1

List<TransactionInput> 1
inputs
List<TransactionOutput>
outputs

1..*

Transaction
Input

Transaction
Output

Abbildung 11: Grundelemente eine Blockchain

Eine Kette (Chain) enthĂ¤lt eine Liste von BlĂścken (Block), ein Block wiederum eine Liste von
Transaktionen (Transaction) und jede Transaktion jeweils eine Liste fĂźr TransaktionseingĂ¤nge
(Transaction Input) und -ausgĂ¤nge (Transaction Output).
Transaktionen kĂśnnen mehrere EingĂ¤nge haben, da der gesamte ausgehende Betrag mit der
Wertigkeit kumulierter EingĂ¤nge bedient werden muss.
Da TransaktionseingĂ¤nge nicht geteilt, sondern einmalig verwendet werden und deshalb
Transaktionsrestwerte (Summe aller EingĂ¤nge â Ausgangsbetrag) entstehen, muss auch die
MĂśglichkeit eines weiteren Transaktionsausgangs bestehen, mit welchem der entstehende
Restbetrag an den Sender Ăźbertragen werden kann.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

31

Anders als in der Bitcoin Blockchain werden Transaktionen und BlĂścke im Prototyp
durchgehend nummeriert, anstelle dessen sie anhand von Zeitstempeln zu verbinden. (vgl.
Kapitel 3.3.3) Diese Nummerierung erlaubt eine einfache Sortierung, unabhĂ¤ngig davon in
welcher Form die daraus bestehende Blockchain persistiert wird.
Ein weiterer Unterschied liegt in der Behandlung der TransaktionsausgĂ¤nge, welche im
Gegensatz zu der Bitcoin Blockchain nicht durchnummeriert werden. Die AusgĂ¤nge werden
im Prototyp so durch ihren Transaktions-Hash und ihre Zieladresse identifiziert, ohne ihre
Position innerhalb der TransaktionsausgĂ¤nge zu berĂźcksichtigen.
4.2.4 Blockgenerierung
Die Blockgenerierung ist generell durch das angewandte Proof-of-Work-Verfahren (vgl.
Kapitel 4.2.6) mit einem hohen Zeitaufwand verbunden, auch wenn dieser im Rahmen des
Prototyps nur einige Sekunden einnimmt. Dies schafft den Anreiz stets einen Block zu
generieren und parallel Transaktionen fĂźr den nĂ¤chsten Block zu sammeln.
Eingehende Transaktionen (vgl. Kapitel 4.2.7) werden in eine Warteschlange aufgenommen,
um eine asynchrone Verarbeitung zu ermĂśglichen. Im Rahmen der Blockgenerierung werden
die Transaktionen auf Korrektheit geprĂźft und in einen neuen Block gegossen.
Die TransaktionsprĂźfung besteht dabei aus mehreren TeilprĂźfungen. ZunĂ¤chst wird die
Konsistenz geprĂźft, indem die Gleichheit der kumulierten Eingangs- und Ausgangswerte
sichergestellt wird. Darauffolgend wird in der Blockchain fĂźr jeden Transaktionseingang nach
einer existierenden Quell-Transaktion gesucht, in welcher der Transaktions-Hash den
angegebenen Eingangs-Hash entspricht und die gleichsam Ăźber einen Ausgang mit passender
Zieladresse und Wertigkeit verfĂźgt. Wenn diese gefunden wurde wird zuletzt nach einer
Transaktion gesucht, welche genau diese bereits als Eingang nutzt, um Doppelausgaben
auszuschlieĂen. Wenn die Konsistenz gegeben ist, alle TransaktionseingĂ¤nge existieren und
gleichsam noch nicht benutzt wurden, gilt die Transaktion als gĂźltig und wird in den Block
aufgenommen.
ZusĂ¤tzlich wird jeder Block mit einer speziellen Belohnungstransaktion ausgestattet, welche
dem Miner, analog zur Bitcoin Blockchain, einen Anreiz geben soll, Prozessorzeit zu
investieren. Ferner stellt diese Belohnung die einzige Art der digitalen Coin-Generierung dar,
wodurch sie essenziell fĂźr jede KryptowĂ¤hrung ist. Anders als in der Bitcoin Blockchain werden
Transaktionen dabei zwecks KomplexitĂ¤tsminderung nicht mit einer TransaktionsgebĂźhr
versehen.
Schlussendlich folgt die Finalisierung des Blocks, indem zunĂ¤chst der Transaktions-Hash und
schlieĂlich der Blockhash mittels Proof-of-Work ermittelt wird. Der fertige Block wird dann

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

32

der lokalen Chain beigefĂźgt und der Sendeinheit Ăźbergeben, die ihn an alle bekannten
Netzwerkteilnehmer verteilt.
Da nicht nur Transaktionen, sondern auch BlĂścke eingehen (vgl. 4.2.7) muss der Prozess der
Blockgenerierung auch abgebrochen werden kĂśnnen, falls ein Block eingeht, welcher die
gegenwĂ¤rtige Blockchain weiter fĂźhrt. Dabei muss berĂźcksichtigt werden, dass der Abbruch
nicht zu InstabilitĂ¤t oder zum Verlust von eingegangenen Transaktionen fĂźhren darf. Diese
Problematik lĂśst der Prototyp mit den folgenden zwei Methoden:
1. Nicht nur die allgemeine Blockgenerierungseinheit, welche innerhalb einer
Endlosschleife

GenerierungsauftrĂ¤ge

initiiert,

sondern

auch

die

einzelnen

GenerierungsauftrĂ¤ge erfolgen in separaten Threads. Diese werden bei Bedarf mittels
InterruptedException (thread.interrupt()) kontrolliert unterbrochen, indem die
Exceptions in den betreffenden Threads abgefangen und behandelt werden.
2. Anstelle dessen Transaktionen direkt aus der Queue zu entnehmen und sie im Falle
eines Abbruchs und Verwurfs des sich in Erstellung befindenden Blocks zu verwerfen,
wird zunĂ¤chst ein Klon der Queue angefordert. Nach erfolgreicher Erstellung und
Einbindung des neuen Blocks in die Chain kĂśnnen dann die verarbeiteten
Transaktionen aus der aktuellen Queue entfernt werden.
Eine detaillierte Modellierung des Ablaufs der Blockerstellung ist unter Anhang H in Abbildung
38 und Abbildung 39 zu sehen.
4.2.5 Kryptografische PrĂźfungen
GrundsĂ¤tzlich muss eine KryptowĂ¤hrung in Rahmen der Blockerstellung, der Blockannahme
und der Annahme von Transaktionen kryptografische PrĂźfungen durchfĂźhren. Dabei ist es
erforderlich zwischen AuthentizitĂ¤tsprĂźfungen mit Hilfe digitaler Signaturen innerhalb der
Annahme von Transaktionen auf der einen, und IntegritĂ¤tsprĂźfungen mit Hilfe von
Hashfunktionen im Rahmen der Blockerstellung und -annahme auf der anderen Seite zu
unterscheiden.
So muss in der Praxis innerhalb einer jeden Blockchain sichergestellt werden, dass jede
Transaktion von einem eindeutig identifizierten Teilnehmer autorisiert wurde, was mittels
asymmetrischer VerschlĂźsselungsverfahren erreicht werden kann. (vgl. Kapitel 3.2.1) Im
Rahmen eines Prototyps, der die wesentlichen Merkmale einer Blockchain inne haben und
lediglich fĂźr Testzwecke zur VerfĂźgung stehen soll, kann hingegen zunĂ¤chst auf diese PrĂźfung
verzichtet werden. Somit wird diese PrĂźfung innerhalb dieser Arbeit nicht weiter behandelt
und jede eingehende Transaktion als autorisiert eingestuft.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

33

Wesentlicher und unverzichtbarer Bestandteil einer Blockchain hingegen ist die
IntegritĂ¤tsprĂźfung, da die Blockchain als Kette von jeweils mit dem VorgĂ¤nger-Hash versehen
BlĂścken bereits grundsĂ¤tzlich auf Hashfunktionen basiert. Der Einsatz von IntegritĂ¤tsprĂźfung
und Hashfunktionen und deren Funktion im Prototyp werden im Folgenden unter Bezug auf
das Klassendiagramm (Anhang G Abbildung 35) beschrieben.
Eingesetzte Hash-Funktion
FĂźr den Prototyp wird die Java-eigene hashCode()-Funktion der Klasse String genutzt. Die
đâ1âđ
Berechnung entspricht dabei der Formel: â(đ ) = âđâ1
. (Oracle, 2010) Somit
đ=0 đ [đ] Ă 31

mĂźssen alle zu hashenden Werte zum Zeitpunkt des Funktionsaufrufs vom Typ String sein. Auf
den Einsatz von SHA-Algorithmen (vgl. Kapitel 3.2.2) wird zunĂ¤chst bewusst verzichtet, um die
KomplexitĂ¤t des Prototyps mĂśglichst gering zu halten.
Unterschiede zur Hash-Funktionen der Bitcoin Blockchain
Im Gegensatz zur Bitcoin Blockchain werden weder Hashwerte von TransaktionseingĂ¤ngen
und -ausgĂ¤ngen, noch die Hashwerte der Transaktionen eines Blocks baumartig und
Paarweise rekursiv gehasht, bis nur noch ein Transaktionshash besteht (vgl. Kapitel 3.1.2),
sondern lediglich aufaddiert. Dies verringert die Sicherheit, verschlankt aber gleichsam den
Code und wird fĂźr Testzwecke als ausreichend erachtet. Zudem werden alle Hash-Funktionen
nur einmal und nicht mehrfach durchlaufen.
Einsatz in Transaktionen
Jede Transaktion hat eine Reihe von Inputs und gleichsam ein bis zwei AusgĂ¤nge1, wobei jedes
Objekt des Typs Transaction (Anhang J Transaction.java), Input (TransactionInput.java) oder
Output (TransactionOutput.java) Ăźber eine eigene hashCode() Methode verfĂźgt. Die
hashCode-Funktion des Objekts TransactionInput lautet â(đđť, đđ) = (31 + đđť) â 31 + đđ 2
und die des Objekts TransactionOutput â(đđ, đđ) = (31 + đđ) â 31 + đđ 3. Der Hash einer
Transaktion ergibt sich aus dem Hash der VorgĂ¤nger Transaktion, der laufenden
Transaktionsnummer,

der

Senderadresse,

der

TransaktionseingĂ¤nge

und

der

TransaktionsausgĂ¤nge und wird dabei wie folgt berechnet: â(đ, đ, đ, đđ¸, đđ´) = đ + đ + đ +
â âđđ âđśđđđ(đđ¸) + â âđđ âđśđđđ(đđ´) 4.

1

Adressen des TransaktionsempfĂ¤ngers und des Transaktionssenders fĂźr evtl. Restwerte vermerkt.
Die Summe der Inputs muss gleich die der Wertigkeit der kumulierten Outputs entsprechen.
2

iH = Eingangs-hash, iV = Eingangswert.

3

oT = Ausgangsziel, oV = Ausgangswert.

4

S = Senderadresse, V = VorgĂ¤ngerhash.

T = Transaktionsnummer, TE = Transaktionseingang, TA = Transaktionsausgang.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

34

Einsatz in BlĂścken
Der Hash eines Blocks ergibt sich aus der Berechnung des Proof-of-Work. Zur DurchfĂźhrung
werden die Challenge und die PoW-Schwierigkeit benĂśtigt, wobei sich die Challenge aus der
Summe dieser Werte ergibt: Der Hashwert des vorangegangenen Blocks, die laufende
Blocknummer und der Transaktions-Hash. Der Transaktionshash wird dafĂźr aus den als String
aneinander geketteten Hashwerten der Einzelnen Transaktionen gebildet. (â(đĄ) =
đđĄđđđđ. âđđ âđśđđđ(đđĄđđđđ(đĄ1 . âđđ âđđđđ( )) + âŻ + đĄđ . âđđ âđđđđ( ))), Anhang J Block.java
â getTransactionHash() : int)
Die Funktionsweise des PoW sowie der Gebrauch der PoW-Schwierigkeit und der Challenge
werden im Kapitel 4.2.6 nĂ¤her betrachtet.
Einsatz in der Blockkette
Die Blockkette selbst verfĂźgt Ăźber keine Hash-Methode, sondern Ăźber Funktionen die der
ĂberprĂźfung der gesamten Chain dienen. Hier wird zum Programmstart die IntegritĂ¤t der
gesamten Blockchain ĂźberprĂźft. (Anhang J Chain.java â getLastValidBlock() : int)
Einsatz in der Netzwerkkommunikation
Jeder aus dem Netzwerk eintreffende Block muss hinsichtlich seiner IntegritĂ¤t geprĂźft werden,
bevor er in die eigene Blockchain integriert werden kann. Innerhalb einer geschlossenen
Testumgebung wird jedoch zunĂ¤chst auf diese PrĂźfung verzichtet, da jeder Teilnehmer Ăźber
die identische Anwendung als Miner der Blockchain verfĂźgt, wodurch jedwede
unkontrollierten Angriffsversuche ausgeschlossen sind.
4.2.6 Proof-of-Work
Im Rahmen der Blockfinalisierung werden zunĂ¤chst der bereits zuvor ermittelte
Transaktionshash, der Hash des vorangegangenen Blocks und die Blocknummer in einer
Challenge als Integer Variable aufaddiert.

Abbildung 12: Codeausschnitt: Proof-of-Work

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

35

Innerhalb der Methode proofOfWork (Abbildung 12) wird daraufhin iterativ ein Wert gesucht,
welcher multipliziert mit der Challenge ein Produkt ergibt, aus dem sich ein Hashwert mit n
fĂźhrenden Nullstellen ergibt (entspricht der Schwierigkeit). Dieser Wert ist der Proof-of-Work.
Der sich aus dem Produkt ergebene Hash ist der Blockhash.
4.2.7 Netzwerkkommunikation
Die Netzwerkkommunikation unter Minern besteht aus zwei Bereichen: Zum einen aus der
Verbindung und Bekanntmachung, zum anderen aus dem Austausch von Transaktionen und
BlĂścken.
Die Bekanntmachung und somit auch der Zugang zum Mining-Netzwerk erfolgt gemĂ¤Ă
Abbildung 13, wobei von einem geschlossenen LAN ausgegangen wird. Jede Node sendet
mittels TimerTask in definierten Zeitintervallen ein DatagramPacket in Form eines Broadcasts
in das Netzwerk, wobei sich innerhalb des DatagramPackets ein JSON-Objekt mit den
Adressdaten der jeweiligen Node und der Typisierung âhandshakeâ befindet. (Anhang J
AddressDataSender.java) Gleichsam hĂ¤lt jede Node einen DatagramSocket aufrecht, welcher
eingehende Broadcasts annimmt und anhand des angegebenen Typs interpretiert. (Anhang J
AddressDataReceiver.java) Eingehende JSON-Objekte des Typs âhandshakeâ werden
akzeptiert und die sich darin befindenden Adressinformationen im Falle bisheriger
Unbekanntheit in die Liste der bekannten Hosts aufgenommen. Zudem werden einem bisher
ungekannten Broadcast-Sender im Gegenzug gezielt die Node-eigenen Adressinformationen
gesendet. (Anhang J Controller.java â addHost(Host))
known hosts
Node A
Node B
Node C

known hosts
Node X

Node X

Broadcast

known hosts
Node B
Node A
Node C

Node A

Node B

known hosts
Node C
Node B
Node A

Node C

address data(Node X)
address data(Node X)
address data(Node X)
address data(Node X)
address data(Node X)
address data(Node A)
address data(Node B)
address data(Node C)

Abbildung 13: Broadcast der Mineradresse

Die Konzeption der Nodes im Bereich der Transaktions- und Blockaustausch-Kommunikation
erfolgt gemĂ¤Ă folgender Definition der Bitcoin-Implementation: âThe Bitcoin network is a
network of homogeneous nodes. There are no coordinating roles and each node keeps a

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

36

complete replica of all the information needed to verify the validity of incoming transactions.
Each node verifies information it receives from other nodes independently and there is only
minimal trust between the nodes. (Decker & Wattenhofer, Information Propagation in the
Bitcoin Network, 2013, S. 3)â Innerhalb der Implementation wird jedoch zwecks
Vereinfachung der Block Generierung anderer Nodes Vertrauen geschenkt. (Vgl. Kapitel 4.2.5)
FĂźr den Blockaustausch bedarf es zweier Eigenschaften: Die des Senders (Anhang J
NetworkSender.java) und die des EmpfĂ¤ngers (Anhang J NetworkReceiver.java). Diese werden
im Folgenden beschrieben.
Start(Block)

i=0
i < list.size()

true
i++

Initialize
dataOutputStre
am

Write Message

Receive and
interpret
Answer

false

End

Answer.finish
!= true
false

true

Get requestet
Block
Send Requestet
Block

Receive and
interpret
Answer

Abbildung 14: Versendung eines Blocks

Die Versendung eines fertigen Blocks verhĂ¤lt sich entsprechend Abbildung 14. Dabei wird der
einzelne Versendungsprozess fĂźr jeden Miner in der Liste der bekannten Hosts durchgefĂźhrt.
ZunĂ¤chst wird der fertige Block als JSON-Objekt in ein Byte Array geladen, dann der Socket
entsprechend des Ziel Hosts initialisiert und schlieĂlich ein Dataoutputstream auf Basis des
Sockets erstellt, mit dem das Byte Array Ăźbertragen werden kann.
Nach der erfolgreichen BlockĂźbertragung wird eine Antwort (ebenfalls im JSON-Format)
erwartet, welche mittels BufferedReader entgegengenommen wird. In dieser kann der
EmpfĂ¤nger bei Bedarf weitere BlĂścke anfordern, indem er das Attribut finish mit false belegt
und die Nummer des nĂ¤chsten zu sendenden Blocks Ăźbergibt. Sobald der EmpfĂ¤nger alle
notwendigen BlĂścke erhalten hat antwortet er mit einem JSON-Objekt, das mit dem
Wertepaar finish und true belegt ist. Dadurch ist der Versendungsprozess abgeschlossen.
Im Rahmen des EmpfĂ¤ngers wird der Empfang von Transaktionen und BlĂścken unterschieden.
Transaktionen werden direkt und ohne PrĂźfung in die Warteschlange der EmpfĂ¤nger-Node
Ăźbernommen, da eine PrĂźfung innerhalb der Blockerstellung ausreichend ist. (Vgl. Kapitel
4.2.4) Empfangene BlĂścke hingegen durchlaufen einen Entscheidungsbaum, da sie nach den
Regeln der Blockchain abgehandelt werden mĂźssen. Dieser Entscheidungsbaum ist auf
Abbildung 15 zu sehen und wird im Folgenden erlĂ¤utert.
FĂźr den korrekten Umgang mit einem eingehenden Block muss zunĂ¤chst der letzte Block der
aktuellen Blockchain BlockN herangezogen werden. Dabei gilt es nur die eingehenden BlĂścke

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

37

nĂ¤her zu betrachten, deren Blocknummer grĂśĂer gleich der des BlockN ist. Dem Prototyp liegt
dazu die Annahme zugrunde, dass stets die lĂ¤ngste Blockchain zu bevorzugen ist. 5 Neben der
zu ermittelnden Blocknummer sind auch stets die Block Hashwerte und die mitgefĂźhrten
PreHashes (Hash des vorhergehenden Blocks) von Bedeutung, da so geprĂźft werden kann, ob
ein eingehender Block zur bisherigen Chain passt. Zudem ist auch die MĂśglichkeit alternativ
gefĂźhrter Blockchain-Branches gegeben, in welcher eingehende BlĂścke gefĂźhrt werden, die
gleichauf mit der aktuellen Chain sind.
Anhand der auf Abbildung 15 zu sehenden Verzweigungen kann der Block so direkt zur
bestehenden Chain hinzugefĂźgt oder abgewiesen werden, oder weiteres Handeln erfordern.
Dies bedeutet im Falle eines empfangenen Blocks, welcher der gefĂźhrten Blockchain weit
voraus ist, alle BlĂścke bis zur Blocknummer von BlockN + 1 vom Sender zu erfragen. Im Falle
eines weiterfĂźhrenden Blocks oder einer weiterfĂźhrenden Blockreihe, in welcher der direkte
numerische Nachfolger von BlockN nicht Ăźber den passenden PreHash verfĂźgt, muss der
Receiver prĂźfen, ob es eine passende parallel gefĂźhrte Chain gibt. Wenn dem so ist, muss
fortan diese als primĂ¤re Blockkette gefĂźhrt werden und der Block/die Blockreihe kann ergĂ¤nzt
werden. Andernfalls ist ein Merge erforderlich, wobei der aktuell letzte eigene Block solange
gegen einen des Senders ausgetauscht wird, bis dessen PreHash dem Hash seines
numerischen VorgĂ¤ngers entspricht. Zum Schluss einer jeden Blockentgegennahme werden
schlieĂlich die alternativen Blockketten, welche kĂźrzer als die nun bestehende Kette sind,
verworfen.

5

Hingegen gilt innerhalb der Bitcoin Blockchain das Gesetz der hĂśchsten KomplexitĂ¤t (vgl. Kapitel
3.1.3): Kumulierte KomplexitĂ¤t der PoWs > Blockchain LĂ¤nge.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

38

Receive Block
- get incoming Block
- get current Block

Inc.nr >
cur.nr

Yes

Inc.prehash ==
cur.hash

No

No

Yes

Inc.nr >
cur.nr+1

Inc.nr == cur.nr &&
Inc.hash != cur.hash

No

Yes
- get incoming Block Nr
- init BlockArray
receivedBlocks
- init blocknumber = inc.nr

Add income
Block to
Blockchain

- init an alternative chain
(clone current)
- remove last block from it

Switch to
alternative chain if
possible

- Ask for Block inc.nr-1
-Add Inc to receivedBlocks
-set blocknumber = inc.nr

Inc.prehash ==
alt.last.hash

Do Nothing

No

Yes

Inc.nr >
cur.nr+1

Yes

Matching alt.
Chain exists

Inc.prehash
== cur.hash

Switch to
alternative chain
if possible

- add block to
alt. Chain

Add income
Block to
Blockchain

Add alt.
Chain to alt.
Chain list

No

No
No

Yes

Yes

Merge
Chains

- merge alt.
Chain and
income

Add incoming
blocks to
Blockchain

Matching alt.
Chain exists
Add incoming
block to
Blockchain

Merge
Chains

Clear
alternativ
chains
Block
processed

Abbildung 15: Empfang eines Blocks

4.2.8 Wallet-Anwendung
FĂźr die Nutzung der Blockchain seitens eines Anwenders ist eine Wallet-Anwendung
erforderlich. Die Mining-Anwendung muss dafĂźr zunĂ¤chst um die ĂbermittlungsmĂśglichkeit
der ganzen Blockchain als JSON ergĂ¤nzt werden. GemĂ¤Ă Anhang G Abbildung 36 wurde dann

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

39

eine Anwendung konzipiert, mit der ein Konto innerhalb der Blockchain genutzt werden kann,
ohne dass der Nutzer die zugrundeliegende Technologie kennen muss. So fordert die WalletSoftware die gesamte Blockchain eines Miners an, um diese auf noch nicht benutzte
Transaktionen, die auf den Nutzer gerichtet sind, zu untersuchen. Die Summe dieser
Transaktionen bildet den angezeigten Kontostand. FĂźr ausgehende Transaktionen bĂźndelt die
Anwendung im Gegenzug EingĂ¤nge so zusammen, dass deren Summe den erforderlichen
Ausgangsbetrag bildet. Eventuelle Restwerte werden in Form eines weiteren Outputs zurĂźck
an den Nutzer selbst geschickt.
4.3

Sicherheit einer Blockchain â Angriffsszenarien

Wenn Sicherheitsmechanismen im Rahmen der Anwendung von Blockchain Technologien
betrachtet werden, muss zunĂ¤chst zwischen der Sicherheit der Anwendungen (z.B. Wallet
Anwendungen) und der Sicherheit der zugrundeliegenden Technologie, also der Blockchain,
unterschieden werden. Gezielte Angriffe (Kannenberg, 2015) oder auch Nutzung von groben
SicherheitslĂźcken (Eikenberg, 2015) im Anwendungsbereich erwecken den Anschein einer
angreifbaren Technologie, beruhen dabei jedoch lediglich auf unausgereiften Entwicklungen
von Wallet-Anbietern und sollen im Folgenden nicht nĂ¤her betrachtet werden. Auch die
Sicherheit der kryptografischen Methoden und Funktionen, welche die grundlegende Basis
einer jeden Blockchain darstellen (Kapitel 3.2), wird im Folgenden als gegeben hingenommen,
um somit die Sicherheit der Blockchain und der mit ihr verbundenen Neuerungen zu
betrachten.
Mit dem Proof-of-Work wird die Gesamtrechenleistung des Netzwerks die grundlegende Basis
einer sicheren Blockchain. Eben dieses Verfahren, welches unter anderem beim Bitcoin zum
Einsatz kommt, ist jedoch mit immensem Rechenaufwand und damit einhergehenden Kosten
verbunden. Je nach eingesetzter Hardware bedeutet dies, âthat the total power used for
Bitcoin mining is around 0.1-10 GW. (OâDwyer & Malone, 2014)â Der durchschnittliche
elektrische Energieverbrauch Irlands wird auf ca. 3 GW beziffert (Eurostat, 2016), ist also
durchaus vergleichbar mit dem des Bitcoin-Netzwerks. Die daraus resultierende Kritik hat zu
Weiterentwicklungen

des

PoW

und

gĂ¤nzlichen

Neuentwicklungen

alternativer

Sicherungsmechanismen beigetragen, welche im Folgenden vorgestellt werden sollen.
4.3.1 Alternative Proof-Of-Konzepte
Proof-of-Stake
Die Stimmgewalt eines Miners im Proof-of-Work folgt aus seiner Rechenleistung, da diese die
Wahrscheinlichkeit der Blockgenerierung im Netzwerk und somit auch seinen Einfluss
bestimmt. Die grundlegende Idee des Proof-of-Stake (PoS) ist die Entkoppelung der

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

40

Stimmgewalt eines Miners von seiner Rechenleistung, hin zur Gewichtung anhand der Anzahl
der sich in seinem Besitz befindenden Coins. Der durch den PoW entstehende Rechenaufwand
und die damit verbundenen Ressourcen sollen somit eingespart werden.
In der Anwendung bedeutet dies, dass mit jedem Tag des Besitzens eines Coins eine Art
Stimmberechtigung wĂ¤chst, wobei je nach Konvention eine Mindest- und HĂśchstdauer
bestimmt wird, die ein Coin im Besitz sein muss um die Wahrscheinlichkeit den nĂ¤chsten Block
generieren zu dĂźrfen zu erhĂśhen. Bei Erfolg wird diese Gewinnchance wieder auf null gesetzt
wodurch die zeitliche Messung des Besitzes von Neuem startet.
Die bei der Blockgenerierung als Belohnung geschaffenen Coins und einbehaltene
TransaktionsgebĂźhren werden zufĂ¤llig und periodisch Ăźber die Coin-Besitzer ausgeschĂźttet,
wobei die AusschĂźttungswahrscheinlichkeit eines Teilnehmers anhand der kumulierten
Wertigkeit der von ihm reprĂ¤sentierten Coins und der Dauer der VerfĂźgungsgewalt Ăźber eben
diese ermittelt wird. (QuantumMechanic, 2011)
Als Schutz vor Manipulation wird nun anders als beim PoW nicht die Rechenleistung, sondern
das VermĂśgen herangezogen. Ein Angreifer muss Ăźber mehr als die HĂ¤lfte des
GesamtvermĂśgens verfĂźgen, um Ăźber eine ausreichend hohe Wahrscheinlichkeit zu verfĂźgen
eine gĂźltige parallele Chain fĂźhren zu kĂśnnen. Neben KryptowĂ¤hrungen wie NXT (Nxt
Community, 2015), welche gĂ¤nzlich auf PoS setzen, ist auch der Einsatz von hybriden Proofof-Verfahren beliebt und wird in KryptowĂ¤hrungen wie Peercoin (Peercoin, 2015) genutzt.
Hier werden verschiedene Kombination und Anteilsmischungen aus PoW und PoS genutzt, um
beide Vorteile zu nutzen und Nachteile zu minimieren.
Proof-of-Activity
Mit dem Proof-of-Activity wird die Idee einer hybriden Blockchain weiter verfolgt, indem zur
gleichen Zeit PoW- und PoS-BlĂścke gesucht werden. Der Idee ist bisher noch keine Umsetzung
gefolgt, allerdings bietet die angestrebte Art der Block Generierung Vorteile hingegen einer
reinen PoW- oder PoS-Methodik. (Patterson, 2015)
So wird zunĂ¤chst ein PoW mit vorgegebener KomplexitĂ¤t gesucht und nach erfolgreicher
Suche ins Netzwerk gesendet. Anders als beispielsweise im Bitcoin-Netzwerk handelt es sich
hier aber noch nicht um einen fertigen Block, denn zunĂ¤chst wird der erzeugte Block Hash in
N Nummern aufgeteilt, wobei jede Nummer auf den Public Key eines beliebigen Coin-Besitzers
verweist. Der Block gilt dann als vollwertig, wenn eine vordefinierte Anzahl der N zufĂ¤lligen
Besitzer den Block mit ihrem jeweiligen Private Key signiert haben. (Bentov, Lee, Mizrahi, &
Rosenfeld, 2014)

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

41

Die Belohnung fĂźr die Block Generierung wird zwischen dem Proof-of-Work-Miner und den
signierenden Teilnehmern aufgeteilt. Somit wird zum einen die Arbeit belohnt und zum
anderen eine Art Verzinsung des Guthabens gewĂ¤hrleistet.
Die im Verfahren inbegriffene MehrfachprĂźfung eines Blocks erschwert somit nochmals eine
Manipulation der Blockchain. Weder dem Netzwerk Ăźberlegene Rechenleistung noch der
Besitz des GroĂteils allen UmlaufvermĂśgens allein genĂźgen fĂźr die realistische Umsetzbarkeit
von nachtrĂ¤glichen VerĂ¤nderungen oder Mehrfachausgaben.
Proof-of-Burn
Die grundsĂ¤tzliche Idee hinter dem Proof-of-Burn (PoB), basierend auf dem Whitepaper von
P4Titan (2014), lautet in Anbetracht der Schwierigkeit der Blockerstellung: âall that matters is
that an individual miner finds the task expensive.â (Bitcoinwiki-N, 2016). Dieser Aussage
folgend wird unter Nutzung des Konzepts PoB keine Rechenleistung verbrannt, sondern
digitale Coins, also das VermĂśgen der Miner. Das Verbrennen einer MĂźnze erfolgt dabei durch
den Versand an eine spezielle im Source Code hinterlegte Adresse.
GrundsĂ¤tzlich ist das Verfahren dem Proof-of-Stake, das ebenfalls eine Zufallsverteilung der
Belohnungen vorsieht, recht Ă¤hnlich. So ist eine Unterscheidung anhand der folgenden drei
Punkte mĂśglich:
1. Anstelle des kumulierten Coin-Alters (Age) werden die Coins als Ganzes verbrannt.
2. Eine Verbrennungsausgabe erfolgt erfolgsunabhĂ¤ngig, wohingegen das Age nur bei
Erfolg zurĂźckgesetzt wird.
3. Die ChancenerhĂśhung fĂźr den Erhalt jeder einzelnen Belohnung ist dauerhaft,
wodurch das Verbrennen von digitalen MĂźnzen zur Investition wird.
Der Einsatz von Proof-of-Burn ist, bedingt durch das vorausgesetzte digitale UmlaufvermĂśgen,
nur in Verbindung mit einem Mining Verfahren mĂśglich. So muss zunĂ¤chst VermĂśgen
geschĂźrft werden, um dann verbrannt werden zu kĂśnnen. Ein Beispiel einer solchen
Verbindung ist die KryptowĂ¤hrung XCP (Counism, 2014), welche basierend auf der Bitcoin
Blockchain um das Proof-of-Burn erweitert wurde. Ein Angriff auf eine solche WĂ¤hrung ist fĂźr
den Angreifer sehr riskant, da er mehr als die HĂ¤lfte aller verbrannten Coins stellen muss,
wodurch sein eingesetztes VermĂśgen anders als bei Proof-of-Stake basierten WĂ¤hrungen bei
Misserfolg unwiederbringlich weg ist.
Proof-of-Capacity
Dem Namen entsprechend setzt der Proof-of-Capacity (PoC) anstelle von Rechenleistung auf
SpeichergrĂśĂe und wird bereits in der KryptowĂ¤hrung Burstcoin (Burst, 2015) eingesetzt.
Neben der angestrebten erhĂśhten Energieeffizienz soll somit auch der Schutz vor Bot-Netzen
gewĂ¤hrleistet werden. Der Aspekt eines Angriffs durch das Leihen von Rechner Ressourcen

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

42

via Trojaner wird somit in den Fokus gerĂźckt und mit einer inhĂ¤renten LĂśsung abgewickelt:
Der Speicherplatzbedarf durch das Verfahren ist so groĂ, dass eine Infizierung durch einen
terabyte-groĂen Trojaner schwerlich unbemerkt bleibt. Als Vorteil gegenĂźber dem Proof-ofWork kann dies aber nur bedingt gewertet werden, da auch eine kontinuierliche vollstĂ¤ndige
CPU Auslastung durch Hash Operationen den infizierten Rechner verlangsamen wird und der
Trojaner somit enttarnt werden kann. (Patterson, 2015)
Das Mining Prinzip des PoC sieht vor, dass Miner Datensegmente (Plots) generieren und auf
der Festplatte speichern. Mit der Indexnummer des letzten Blocks der aktuellen Chain wird
dann aus jedem Plot eine Scoop (Schaufel) genommen. SchlieĂlich ist analog zum Proof-ofWork ein PoC gefunden, wenn der gemeinsame Hashwert von Scoop und dem letzten Block
Header, je nach Schwierigkeit, mit n Nullstellen beginnt. (Cordell, 2014) Jedes Megabyte
allokierter Speicher kann also als zusĂ¤tzliches Los fĂźr die Findung eines PoC betrachtet
werden.
Mit einer solchen Implementierung birgt der PoC aber zwei Probleme: Zum einen kann ein
Miner mangels Rechenaufwand ohne Kosten gleichzeitig durch Untersuchung aller Plots an
beliebig vielen alternativen Chains arbeiten. Zum anderen erfordert der Speicherzugriff auf
eine Festplatte Zeit (im Schnitt 9ms (ITWissen, 2016)), wodurch die spontane Erstellung von
Scoops im Hauptspeicher effizienter sein kann. Damit wĂ¤re wiederum ein simpler Proof-ofWork Algorithmus implementiert.
Weitere Ideen
Neben den hier genannten Konzepten existieren noch einige weitere, welche zum groĂen Teil
als leicht abgewandelte Kopien des Proof-of-Work oder Proof-of-Stake abgetan werden
kĂśnnen. Es gibt hingegen auch andere Varianten, wie der Proof-of-Storage mit dem EntwĂźrfe
dezentralisierter Cloud Speicher umgesetzt werden. (Ateniese, Kamara, & Katz, 2009) Solche
verhĂ¤ltnismĂ¤Ăig exotischen Verfahren bergen unter Nutzung von Blockchain-Technologie und
Netzwerkprotokollen neue und andere MĂśglichkeiten, sodass sie gĂ¤nzlich separat betrachtet
werden mĂźssen und innerhalb dieser Arbeit nicht weiter untersucht werden kĂśnnen.
4.3.2 Theoretische Angriffe auf Blockchain-Konzepte
Bei Nutzung einer Blockchain-Technologie sind verschiedene Angriffsszenarien denkbar. An
dieser Stelle sollen zwei Angriffsszenarien vorgestellt und darauffolgend in Hinblick auf ihren
mĂśglichen Erfolg je nach Proof-of-Konzept untersucht werden: Die Doppelausgabe und die
nachtrĂ¤gliche VerĂ¤nderung. Als zu untersuchende Proof-of-Konzepte werden dabei PoW und
PoS herangezogen, da sie die hĂśchste praktische Relevanz haben. (Vgl. Kapitel 2.1)

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

43

Die Doppelausgabe
Die Grundidee einer Doppelausgabe liegt darin, eine digitale MĂźnze stets kopieren und an
mehrere Teilnehmer gegen eine Gegenleistung eintauschen zu kĂśnnen. (Bitcoin.org, 2015a)
Dies wird innerhalb der Blockchain verhindert, indem ein Transaktionsausgang nur einmal
innerhalb der gesamten Blockchain-Historie verwendet werden kann. (Vgl. 4.2.4)
Um dennoch das Ziel der TĂ¤uschung eines Teilnehmers zu erreichen, muss ein Angreifer
analog der Abbildung 16 zur gleichen Zeit zwei BlĂścke, A und B, erstellen, wobei Block A eine
an das Betrugsopfer gerichtete und Block B eine an den Sender selbst gerichtete Transaktion
gleichen Ursprungs enthĂ¤lt.
So soll der Betrogene Block A erhalten, bei PrĂźfung feststellen, dass die empfangene
Transaktion gĂźltig ist und eine dafĂźr vereinbarte Gegenleistung erbringen. Gleichsam erhĂ¤lt
das Mining-Netzwerk Block B, der die an den BetrĂźger selbst gerichtete Transaktion enthĂ¤lt,
und befindet diesen Block als gĂźltig, wodurch Block A und die sich darin befindende
Transaktion nachtrĂ¤glich unwirksam wird.

Block n
(Variante A)

Block n-1

Betrogener
Block n+1 (mit
Variante B)

Angreifer

Block n
(Variante b)

Minernetzwerk

Abbildung 16: Erfolgreiche Doppelausgabe

Die nachtrĂ¤gliche VerĂ¤nderung
Die Grundidee der nachtrĂ¤glichen VerĂ¤nderung der Blockchain beruht darauf, dass ein einmal
erstellter und allgemein anerkannter Block niemals final und somit endgĂźltig ist. Eine lĂ¤ngere
bzw. komplexere Kette als die bisher anerkannte kann also zum Austausch aller bestehenden
BlĂścke fĂźhren. (Bitcoin.org, 2015b) Neben destruktiv motivierten Anreizen eines solchen
Angriffs bestehen auch finanzielle Reize im Form der Aneignung von Belohnungstransaktionen
und der AbĂ¤nderung bestehender Transaktionen zu Gunsten des Angreifers.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

1

MinerNetzwerk

2

3

SEITE

4

5

6

7

44

8

Angreifer
Abbildung 17: NachtrĂ¤gliche VerĂ¤nderungen durch einen Angreifer

Die DurchfĂźhrung eines solchen Angriffs wĂźrde entsprechend Abbildung 17 erfolgen, indem
das Miner-Netzwerk bereits eine Blockkette bis zum Stand 6 erzeugt hat und ein Angreifer
aufbauend auf Block 1 des Netzwerkes selbst an einer alternativen Kette arbeitet. Diese soll
die KomplexitĂ¤t der bisher gĂźltigen Blockchain Ăźbertreffen und somit nach den Regeln des
Blockchain-Netzwerkes Ăźbernommen werden, wobei im Falle der Abbildung die BlĂścke 2 bis
6 des Mining-Netzwerkes durch die alternativen BlĂścke des Angreifers ersetzt werden.
4.3.3 Abwehrmechanismen
Um Angriffe abzuwehren gibt es verschiedene Herangehensweisen. GrundsĂ¤tzliche
Konventionen,

an

die

sich

alle

Teilnehmer

halten

sollten,

implementierte

Sicherheitsmechanismen im Code der Miner und Architektur Entscheidungen in Form des
Proof-of-Konzepts. Im Folgendem sollen Absicherungen gegen die Doppelausgabe und die
nachtrĂ¤gliche VerĂ¤nderung beschrieben werden.
Die Doppelausgabe
Die Akzeptanz einer als doppelt ausgegebenen Transaktion als ZahlungsempfĂ¤nger lĂ¤sst sich
ohne technische LĂśsung vermeiden, indem auf weitere BlĂścke der Miner gewartet wird, die
nach dem relevanten Block entstehen. Sollte so wie in Abbildung 18 eine Blockchain zustande
gekommen sein, in welcher drei BlĂścke nach der Zahlungstransaktion enthalten sind und die
Transaktion in fĂźr den EmpfĂ¤nger korrekter Form enthalten ist, kann der EmpfĂ¤nger eine
Gegenleistung erbringen. Andernfalls sind die UngĂźltigkeit der zunĂ¤chst empfangenen
Transaktion und damit auch der Betrugsversuch bewiesen.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

45

Block n
(Variante A)

Block n-1

Miner
netzwerk

Angreifer

Block n+1
(Variante A
oder B)

Block n+3
(Variante A
oder B)

Betrogener

Block n
(Variante b)
Abbildung 18: Gescheiterte Doppelausgabe

Eine technische AbwehrmĂśglichkeit stellt der Einsatz des Proof-of-Work da. Aufgrund der
dafĂźr benĂśtigten Rechenleistung ist es fĂźr einen Miner bereits schwer, einen Block mit einer
korrekten Transaktion zu erstellen, welcher als erster die generelle Blockkette weiterfĂźhrt und
somit in ihr aufgenommen wird. Die gleichzeitige Erstellung mehrerer BlĂścke kann somit
nahezu ausgeschlossen werden. Der Einsatz von Proof-of-Stake beispielsweise hat diesen
Schutz nicht, da hier keine Rechenleistung erforderlich ist. Die konsequente Einhaltung nicht
technischer Konventionen ist somit zwingend notwendig.
Die nachtrĂ¤gliche VerĂ¤nderung
Die MĂśglichkeit einer Ănderung der Blockchain ist maĂgeblich von dem verwendeten Proofof-Konzept abhĂ¤ngig, welches die dafĂźr notwendigen Voraussetzungen bestimmt. Zudem
besteht die MĂśglichkeit BlĂścke als Meilensteine direkt im Source Code zu hinterlegen und
damit zu finalisieren. Eine Ănderung vor einem solchen Meilenstein ist somit ausgeschlossen,
wodurch die Tragweite einer mĂśglichen Ănderung eingedĂ¤mmt wird.
Die grundsĂ¤tzliche Abwehrmethode unter Einsatz des PoW ist die Einbeziehung der
KomplexitĂ¤t, also der kumulierten Schwierigkeit des PoW der aktiven und der alternativen
Blockchain. Somit wird verhindert, dass eine lĂ¤ngere Chain Ăźbernommen wird, welche in
wenigen Minuten mit geringstmĂśglicher PoW-Schwierigkeit erstellt wurde. Da die
Anerkennung einer alternativen Blockchain also die gleiche Blockchain-KomplexitĂ¤t erfordert,
muss ein Angreifer auch Ăźber die RechenkapazitĂ¤t verfĂźgen, die die Erstellung einer
Blockchain von gleicher Schwierigkeit erfordert. Er muss somit Ăźber eine dem Mining
Netzwerk gleichende RechenkapazitĂ¤t verfĂźgen, um eine 50-prozentige Chance zu haben, nur
den nĂ¤chsten Block zu erstellen. Eine rĂźckwirkende VerĂ¤nderung, welche das Ăberhohlen der
Chain erfordert, bedingt also einen GroĂteil der Gesamtrechenleistung des MiningNetzwerkes. Je nach NetzwerkgrĂśĂe kann dies eine immense oder aber geringe HĂźrde sein.
Die Abwehrmethode unter Einsatz des PoS unterscheidet sich dahingehend, dass die
RechenkapazitĂ¤t eines Angreifers irrelevant ist. Nur die ihm zur VerfĂźgung stehenden Coins
sind von Bedeutung. Eine kontinuierliche Ăberstimmung aller Miner, die im Rahmen einer

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

46

rĂźckwirkenden Ănderung notwendig ist, erfordert deshalb mehr als die HĂ¤lfte der sich im
Umlauf befindenden Coins. Diese HĂźrde kann bereits in einem kleinen Netzwerk nahezu
unĂźberwindbar sein, mit wachsendem Handelsvolumen steigt die HĂźrde noch weiter an.
4.3.4 Versuch: Angriff auf den Prototyp (Proof-of-Work)
Nach theoretischer Betrachtung mĂśglicher Angriffsszenarien soll ein Angriff auf den Prototyp
Aufschluss Ăźber die ErfolgsmĂśglichkeit eines wesentlichen Ănderungsversuchs einer noch
jungen Blockchain6 geben. Dazu soll eine Testumgebung aufgebaut werden, in welcher sich
drei Miner befinden, wobei einer die Rolle des Angreifers einnimmt. Gleichsam wurde eine
Visualisierung implementiert, die den aktuellen Stand der drei Konkurrierenden Miner anzeigt
und schlieĂlich auch den Erfolg oder Misserfolg eines Angriffs darstellt. Damit eine
Visualisierung gut beobachtbar und nachvollziehbar ist, ist eine gewisse Dauer der
Blockgenerierung der einzelnen Miner von NĂśten. Diese wird bedingt durch die eingesetzten
Hash Verfahren nicht erreicht, sodass eine zufĂ¤llige VerzĂśgerung zwischen 0 und 120
Sekunden7 innerhalb der Block Generierung eingebaut wurde. Die Rechenleistung der
Teilnehmer spielt somit innerhalb der Versuchsumgebung eine untergeordnete Rolle.
Die Visualisierung
Als Visualisierungseinheit dient eine Java-Applikation, welche eine NachrichtenempfĂ¤ngereinheit in Form eines stets aktiven ServerSockets und eine grafische OberflĂ¤che in Form einer
JavaFX Stage enthĂ¤lt. Dazwischen befindet sich eine Interpretationseinheit, welche die von
den Minern eingehenden Log-EintrĂ¤ge anhand ihres vordefinierten Codes erkennt. Die somit
identifizierbaren mitgegebenen Informationen werden ausgelesen und schlieĂlich der
Anzeigeeinheit Ăźbergeben. Der konkrete Aufbau ist als Klassendiagramm in Anhang G
Abbildung 37 zu finden.
Zudem wurden die Miner um eine Schnittstelle in Form eines AppenderSkeleton erweitert,
sodass jeder Log-Eintrag mittels DataOutputStream an die zentrale Visualisierungseinheit
versendet werden kann. (Anhang J RemoteAppender.java) Beim AppenderSkeleton handelt es
sich um eine Komponente der Log4J Bibliothek, in welcher jeder Log-Aufruf innerhalb einer
Anwendung als Ereignis auftritt und einen Methodenaufruf zufolge hat. Dieser wurde mit
eigener Logik implementiert, die zum einen aus dem Auslesen des konkreten Log-Eintrags in
einen String und zum anderen in der Aufnahme und dem SchlieĂen einer Socket-Verbindung
mit der Visualisierungseinheit zwecks Ăbertragung des Strings besteht.

6

Eine Chain an deren Miningprozess erst wenige Nodes beteiligt sind (< 100 Miner).

7

Vgl. Anhang J BlockGenerator.java â Zeile 53 & 30.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

47

Der Angreifer
Als Angreifer dient eine leicht erweiterte Form des prototypischen Miners. So wird die
Konfigurationsdatei um die EintrĂ¤ge attacker (boolean) und speed (int) erweitert und
innerhalb der Programminitialisierung eingelesen. Die Annahme von BlĂścken anderer Miner
wird abhĂ¤ngig vom Wert attacker gemacht, wobei ein Angreifer (attacker = true) eingehende
BlĂścke ignoriert und somit stets sein Ziel verfolgt die eigene Blockchain durchzusetzen. Der
Eintrag speed wird als Divisor der zufĂ¤lligen VerzĂśgerungszeit genutzt, wodurch eine
Beschleunigung des Angreifers gegenĂźber den regulĂ¤ren Minern ermĂśglicht wird.
DurchfĂźhrung
Die beiden regulĂ¤ren Miner sollen eine neue Blockchain erstellen. Sie erhalten bei einer
Geschwindigkeit von 1 (speed=1) einen Vorsprung von 10 Minuten. Danach wird auch der
Angreifer gestartet, wobei dieser eine Geschwindigkeit von 3 annimmt. Da er somit schneller
ist als das Gesamtnetzwerk, welches Ăźber eine kumulierte Geschwindigkeit von 2 verfĂźgt,
sollte er im Stande sein innerhalb von 20 Minuten Ăźber eine ebenso lange Blockchain zu
verfĂźgen.8 Nachdem der Angreifer Ăźber die lĂ¤ngste Chain innerhalb des Netzwerk verfĂźgt,
wird die Ăbernahme dieser Kette seitens der Miner erwartet.
Ergebnis
Nach 10 Minuten verfĂźgte die verteilte Blockchain Ăźber 17 BlĂścke. Anhang I Abbildung 40 zeigt
den vom Viewer angezeigten Stand nach 16 Minuten. Die ersten beiden Zeilen zeigen dabei
den Status der regulĂ¤r arbeitenden Miner 1 (Gelb) und 2 (Blau), die dritte Zeile wiederum die
Chain des Angreifers (Pink), welcher zu diesem Zeitpunkt noch 7 BlĂścke zurĂźck lag. In
Abbildung 41 liegen alle Miner gleichauf bei einer KettenlĂ¤nge von 31 BlĂścken nach 20
Minuten. Eine Minute spĂ¤ter konnte der Angreifer schlieĂlich das Netzwerk mit seinen Block
33 Ăźberholen, um Miner 1 und 2 nacheinander den eigenen Stand erfolgreich anbieten zu
kĂśnnen, wodurch alle bisherigen BlĂścke seitens der ehrlichen Miner verworfen werden
mussten. (Abbildung 42, Abbildung 43)
Dieses Angriffsszenario verdeutlicht neben der korrekten Funktion des Prototyps vor allem die
Verwundbarkeit einer auf Proof-of-Work basierenden Blockchain, welche Ăźber nur geringe
RechenkapazitĂ¤ten verfĂźgt. Dabei kann der Test durchaus in die RealitĂ¤t Ăźbertragen werden,

8

Angreifer hat eine Geschwindigkeit von 3, wodurch er zwischen 0 und 40 Sekunden/Blockerstellung
benĂśtigt. Bei durchschnittlich 20 Sekunden/Blockerstellung hĂ¤tte er somit in 20 Minuten 60 BlĂścke
generiert.
Miner haben eine kumulierte Geschwindigkeit von 2, wodurch sie zwischen 0 und 60
Sekunden/Blockerstellung benĂśtigen. Bei durchschnittlich 30 Sekunden/Block hĂ¤tten sie somit in 30
Minuten 60 BlĂścke generiert.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

48

wo der Verbund GHash bereits am 12. Juni 2012 âĂźber zwĂślf Stunden mehr als 51 Prozent der
Rechenleistung fĂźr Bitcoins gestellt [hat]. (Ernst, 2014)â Somit bestand bereits auch im GroĂen
die MĂśglichkeit einer solchen Manipulation.
4.4

Kritische Reflexion

Der im Rahmen dieser Arbeit erstellte Prototyp kann als Basis einer Blockchain genutzt
werden. FĂźr die Entwicklung zur vollwertigen KryptowĂ¤hrung bedĂźrfte es dabei noch
Erweiterungen, in Form von komplexen Hash-Verfahren, AuthentizitĂ¤tsprĂźfungen, alternative
Herangehensweisen zur Findung eines PoW und Optimierungen in der Netzwerk
Kommunikation. Dennoch wird er seinen funktionalen Anforderungen gĂ¤nzlich gerecht, indem
er die Grundmechanismen einer fĂźr den realen Einsatz tauglichen Blockchain beherrscht.
GemĂ¤Ă den Anforderungen kĂśnnen Chains erstellt werden, wobei eingehende Transaktionen,
zwischengespeichert in einer Queue, sicher in BlĂścken erfasst werden. BlĂścke (und bei Bedarf
Blockreihen) kĂśnnen an andere Miner versendet und eingehende BlĂścke anderer Teilnehmer
interpretiert und ggf. aufgenommen werden. Manipulationen der Chain werden dabei durch
IntegritĂ¤tsprĂźfungen erkannt. Auch die Bekanntmachung der Nodes innerhalb eines
geschlossenen Netzwerkes mittels Broadcasts ist ohne einen weiteren Dienst mĂśglich.
Die nicht funktionalen Anforderungen wurden mittels einer Wallet-Anwendung realisiert. Mit
ihr kĂśnnen Transaktionen versendet und der aktuelle Kontostand sowie auf die eigene
Adresse gerichtete Transaktionen angezeigt werden. Zudem kann der Status mehrerer Miner
mittels Visualisierungsanwendung angezeigt und untersucht werden.
Neben den analysierten AngriffsmĂśglichkeiten, welche je nach Ausgangsbedingungen keine
oder schwerwiegende SchĂ¤den verursachen kĂśnnen, verdeutlicht die Entwicklung des
Prototyps

weitere

Problematiken

der

Technologie.

Die

umfangreiche

Netzwerk

Kommunikation lĂ¤sst das AusmaĂ des Kommunikationsaufwandes einer Blockchain erkennen,
bei der der stĂ¤ndige Abgleich der je Miner gefĂźhrten Blockchain zur Notwendigkeit mehrerer
gleichsam offen gehaltenen Socket-Verbindungen fĂźhrt. Eine Limitierungen des BitcoinNetzwerkes, durch die maximal 7 Transaktionen pro Sekunde aufgenommen werden kĂśnnen,
ist die Folge (Swan, 2015, S. 83).
Unter BerĂźcksichtigung der SchwĂ¤chen, welche besonders wie im Beispielangriff zu sehen
noch junge KryptowĂ¤hrungen in kleinen Netzwerken betreffen, kann dennoch eine sichere
und gleichsam ressourcenschonende Implementation entstehen. Hier kann der Einsatz
hybrider Proof-of-Konzepte zu einer zuverlĂ¤ssigen und Ressourcen schonenden Blockchain
fĂźhren.
Eine solche zuverlĂ¤ssige Technologie kann dann um weitere Informationen erweitert werden,
sodass nicht nur eine Funktion als KryptowĂ¤hrung, sondern auch als Datenspeicher mĂśglich

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

49

wird. Innerhalb dieser transaktionsgebundenen Speichereinheiten kĂśnnen nicht nur einfache
Dokumente, sondern auch ausfĂźhrbare Programme gespeichert und innerhalb einer in den
Minern laufenden virtuellen Umgebung ausgefĂźhrt werden. Diese Programme dienen in
heutigen AnwendungsfĂ¤llen als Smart Contracts.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

5

SEITE

50

Fachliche Konzeption eines Smart Contracts

In diesem Unterkapitel wird die GeschĂ¤ftsidee vorgestellt, um den in Kapitel 2.2 vorgestellten
Smart Contracts einen praktischen Nutzen zu geben. Die GeschĂ¤ftsidee ist in der
Finanzbranche beheimatet, genauer gesagt im Derivathandel. Aus diesem Grund wird
zunĂ¤chst eine EinfĂźhrung in den Derivathandel gegeben. Daraufhin folgt die Konkretisierung
des GeschĂ¤ftsvorfalls, die Abbildung des Derivathandles in einer dezentralen Anwendung.
Zum Abschluss des Unterkapitels werden praktische und rechtliche EinschrĂ¤nkungen der Idee
betrachtet.
5.1

EinfĂźhrung in den Derivathandel

Wenn Unternehmen GeschĂ¤fte abschlieĂen, deren ErfĂźllungspflicht in der Zukunft liegt,
entsteht hĂ¤ufig ein finanzielles Risiko fĂźr das Unternehmen. Dieses Risiko ist durch die
schwankenden Marktpreise von Rohstoffen, Zinsen, WĂ¤hrungen, Aktien und weiteren
materiellen und nicht materiellen GĂźtern begrĂźndet (HeldtB).
Ein kurzes Beispiel soll diese Risiken verdeutlichen: So verpflichtet sich Beispielsweise ein
deutsches Unternehmen vertraglich dazu, in einem Jahr Waren an ein US-amerikanisches
Unternehmen zu liefern. Das amerikanische Unternehmen verpflichtet sich im Gegenzug dazu,
den heute vereinbarten Rechnungsbetrag in einem Jahr in US-Dollar zu bezahlen. Mit der
Unterzeichnung des Vertrages geht das deutsche Unternehmen ein WĂ¤hrungsrisiko ein, da
der Wechselkurs von Euro und Dollar Schwankungen unterliegt (SchĂśning).
Zur Kompensation dieser finanziellen Risiken kĂśnnen DerivatvertrĂ¤ge abgeschlossen werden.
Genauer gesagt einen Forward-Kontrakt mit Cash-Settlement. Ein Forward-Kontrakt ist eine
Vereinbarung ein bestimmtes Gut zu einem bestimmten Zeitpunkt, zu einem bestimmten
Preis abzunehmen (Hull, 2015, S. 29). Cash Settlement bedeutet in diesem Fall, dass nicht das
Gut selber abgenommen bzw. geliefert wird, sondern nur eine Ausgleichszahlung zum
verĂ¤nderten Marktpreis stattfindet (HeldtA).
Die Unterzeichnung eines Derivatvertrages bedeutet ein weiteres finanzielles Risiko fĂźr die
beteiligten Unternehmen. Das Solvenzrisiko, dass einer der beteiligten Parteien seiner
Zahlungsverpflichtung nicht nachkommen kann. Um dieses Risiko zu mindern, wird hĂ¤ufig eine
unabhĂ¤ngige dritte Partei eingeschaltet â das sogenannte Clearinghouse. Das Clearinghouse
ist ein TreuhĂ¤nder, welcher die Margin Konten der Vertragsparteien verwaltet (Hull, 2015, S.
57 ff).
Die nachfolgende Tabelle soll die Arbeitsweise des Clearinghouses verdeutlichen. Es ist ein in
Anlehnung an (Hull, 2015, S. 57 ff), angepasstes Beispiel. Die beiden Unternehmen A und B
haben gegensĂ¤tzliche Positionen eingenommen. Unternehmen A ist aus deutscher Sicht ein

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

51

exportierendes Unternehmen und erhĂ¤lt in einem Jahr eine Zahlung Ăźber 110.000 $, was zum
jetzigen Zeitpunkt 100.000 âŹ entspricht. Unternehmen B ist aus deutscher Sicht ein
importierendes Unternehmen, welches in einem Jahr eine Rechnung Ăźber 110.000 $
begleichen muss. Da beide Unternehmen in der internen Kostenrechnung mit dem aktuellen
Wechselkurs (1 âŹ = 1,10 $) gerechnet haben, wollen sie diesen Wechselkurs Ăźber einen
Derivatvertrag absichern. Um kein Solvenzrisiko einzugehen, entschlieĂen sich beide
Unternehmen den Derivatvertrag Ăźber ein Clearinghouse abwickeln zu lassen.
Zum 1. Januar mĂźssen die Unternehmen jeweils eine Sicherheitsleistung (Margin) in HĂśhe von
10.000 âŹ an das Clearinghouse Ăźberweisen. Das Clearinghouse fĂźhrt fĂźr die beiden
Unternehmen jeweils ein internes Konto, auf welchem sich zum 1. Januar jeweils 10.000 âŹ
befinden. Die Aufgabe des Clearinghouse ist es, ein tĂ¤gliches Settlement der beiden Konten
anhand des tagesaktuellen Wechselkurs durchzufĂźhren.
Zum 2. Januar betrĂ¤gt der Wechselkurs nicht mehr 1 âŹ = 1,10 $, sondern 1 âŹ = 1,12 $. Diese
KursverĂ¤nderung wĂ¤re ohne einen Derivatvertrag fĂźr das importierende Unternehmen B
positiv, da es weniger Euro aufwenden muss, um seine Rechnung in Dollar zu bezahlen. Im
Umkehrschluss wĂ¤re diese KursverĂ¤nderung fĂźr das exportierende Unternehmen B negativ,
da es fĂźr die erhaltenen Dollar weniger Euro erhĂ¤lt. Durch den Derivatvertrag verzichten beide
Unternehmen jedoch auf Gewinne aus fĂźr sie positiven KursverĂ¤nderungen, sowie auf
Verluste aus fĂźr sie negativen KursverĂ¤nderungen. Aus diesem Grund gleicht das
Clearinghouse die Konten der beiden Vertragsparteien genau um die HĂśhe der entstandenen
Kursgewinne bzw. Kursverluste aus. In diesem Fall wird das Konto von Unternehmen B mit
1785,71 âŹ belastet und dem Konto von Unternehmen A gutgeschrieben.
Am 3. Januar entwickelt sich der Kurs in die entgegengesetzte Richtung, sodass das Konto von
Unternehme A mit 3.637,57 âŹ belastet wird und dem Unternehmen B gutgeschrieben wird.
Diesen Ausgleich fĂźhrt das Clearinghouse nun bis zum Ende der Vertragslaufzeit weiter durch.
Am 12. MĂ¤rz entsteht jedoch die Besonderheit, dass das Margin Konto des Unternehmens B
unterhalb der Maintenance Margin von 5000 âŹ sinken wĂźrde. Das Unternehmen B Ăźberweist
daraufhin weitere 5000 âŹ auf sein Konto beim Clearinghouse. WĂźrde das Unternehmen B der
Zahlungsaufforderung nicht nachkommen, so wĂźrde der Derivatvertrag aufgelĂśst und beide
Parteien in der HĂśhe ihrer KontostĂ¤nde ausbezahlt. Das Unternehmen A mĂźsste sich in diesem
Fall einen anderen Vertragspartner suchen, um dem Wechselkursrisiko weiterhin entgegen zu
wirken.
Dieser Prozess aus tĂ¤glichem Ausgleich und eventuellen Nachzahlungen in Form von Margin
Calls setzt sich bis zum 31. Dezember fort, sofern die beiden Unternehmen den mĂśglichen
Zahlungsaufforderungen nachkommen. An diesem Tag werden den beiden Unternehmen die
verbleibenden BetrĂ¤ge der Konten ausbezahlt.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

Datum

Unt. A

Unt. B

Kurs

SEITE

Summe Euro

Ănderung

01. Jan

10.000,00 âŹ

10.000,00 âŹ

0,9091 âŹ

100.000,00 âŹ

02. Jan

11.785,71 âŹ

8.214,29 âŹ

0,8929 âŹ

98.214,29 âŹ

1.785,71 âŹ

03. Jan

8.148,15 âŹ

11.851,85 âŹ

0,9259 âŹ
.

101.851,85 âŹ -

3.637,57 âŹ

52

Margin Call

.
.
12. Mrz
13. Mrz

16.779,66 âŹ
17.563,03 âŹ

8.220,34 âŹ
7.436,97 âŹ

0,8475 âŹ
0,8403 âŹ
.
.
.

93.220,34 âŹ
92.436,97 âŹ

8.631,51 âŹ 5.000 Unt. B
783,36 âŹ

29. Dez
30. Dez
31. Dez

18.333,33 âŹ
21.290,32 âŹ
22.000,00 âŹ

6.666,67 âŹ
8.709,68 âŹ
8.000,00 âŹ

0,8333 âŹ
0,8065 âŹ
0,8000 âŹ

91.666,67 âŹ
88.709,68 âŹ
88.000,00 âŹ

770,31 âŹ
2.956,99 âŹ 5.000 Unt. B
709,68 âŹ

Tabelle 2: Beispiel Clearinghouse

Betrachtet man die Gesamtrechnung, so ist festzustellen, dass Unternehmen A zu Beginn des
Clearingvertrags 10.000 âŹ an das Clearinghouse bezahlt hat und zum Ende der Vertragslaufzeit
22.000 âŹ fĂźr den verĂ¤nderten Wechselkurs vom Clearinghouse erhĂ¤lt. Daneben erhĂ¤lt
Unternehmen A die 110.000 $ aus seiner GeschĂ¤ftstĂ¤tigkeit. Dies entspricht mit dem
tagesaktuellen Wechselkurs verrechnet 88.000 âŹ. Somit erhĂ¤lt Unternehmen A genau die
100.000 âŹ, mit welchen es zum Zeitpunkt des Vertragsabschlusses gerechnet hat.
An Clearinghouse bezahlt:

10.000 âŹ

ErhĂ¤lt von Clearinghouse:

22.000 âŹ

ErhĂ¤lt Dollar 110.000 $ * (1/1,25):

88.000 âŹ

Effektiv erhalten:

100.000 âŹ

Tabelle 3: Endrechnung Unternehmen A

Unternehmen B hingegen hat Ăźber die Initial Margin von 10.000 âŹ und zwei Margin Calls a
5.000 âŹ insgesamt 20.000 âŹ an das Clearinghouse Ăźberwiesen. FĂźr den verĂ¤nderten
Wechselkurs erhĂ¤lt es am Ende der Laufzeit des Derivatvertrags 8.000 âŹ vom Clearinghouse
zurĂźck. FĂźr die Begleichung seiner Rechnung Ăźber 110.000 $ muss Unternehmen B 88.000 âŹ
aufwenden. Somit hat Unternehmen B insgesamt die kalkulierten 100.000 âŹ bezahlt.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

An Clearinghouse bezahlt:(Margin)

SEITE

10.000 âŹ

An Clearinghouse bezahlt (Margin Call):

5.000 âŹ

An Clearinghouse bezahlt: (Margin Call):

5.000 âŹ

ErhĂ¤lt von Clearinghouse:

8.000 âŹ

Bezahlt Dollar: 110.000 $ * (1/1,25)
Effektiv bezahlt:

53

88.000 âŹ
100.000 âŹ

Tabelle 4: Endrechnung Unternehmen B

Bei der Berechnung sind GebĂźhren fĂźr das Clearinghouse sowie Zinsbelastungen fĂźr das
gebundene Kapital durch die Margins bewusst nicht einberechnet worden, da sie fĂźr die
Absicherung des Marktpreises nur eine untergeordnete Rolle spielen. Weiterhin wird nicht
betrachtet, dass die aktuellen Spot Kurse und die fĂźr DerivatvertrĂ¤ge verwendeten Forward
Kurse in der Regel geringe Unterschiede aufweisen (Hull, 2015, S. 28).
5.2

Idee

Die Idee fĂźr den GeschĂ¤ftsvorfall ist es, den in Kapitel 2.2 beschriebenen Nutzen und die
MĂśglichkeiten einer dezentralen Anwendung fĂźr das Clearing eines Derivatvertrags zu nutzen.
Genauer gesagt soll das Clearinghouse durch eine dezentrale Anwendung auf Basis der
Blockchain-Technologie ersetzt werden.
Der wesentliche Grund, weshalb die beiden Vertragsparteien eines Derivatvertrags auf ein
Clearinghouse zurĂźckgreifen, ist mangelndes Vertrauen der Vertragsparteien gegenĂźber der
jeweils anderen Partei. Dieses unzureichende Vertrauen ist primĂ¤r mit der unbekannten oder
nur schwer einzuschĂ¤tzenden ZahlungsfĂ¤higkeit des anderen Vertragspartners begrĂźndet.
Daher wird in der Regel eine unabhĂ¤ngige dritte Partei eingeschaltet, welcher beide Parteien
ein hĂśheres Vertrauen entgegenbringen â das Clearinghouse. (Hull, 2015, S. 58)
Die Hinzunahme eines Clearinghouses bringt fĂźr die beiden Vertragsparteien den Vorteil, dass
sie nicht in die Solvenz des anderen Vertragspartners vertrauen mĂźssen. Daneben mĂźssen die
Vertragsparteien keine Ressourcen fĂźr das Clearing im eigenen Haus vorhalten.
Durch die Hinzunahme eines unabhĂ¤ngigen Dritten entstehen jedoch auch Nachteile, so
mĂźssen GebĂźhren fĂźr das Clearing bezahlt werden. AuĂerdem muss nicht mehr in die Solvenz
des Vertragspartners vertraut werden, jedoch in die Solvenz des Clearinghouses. (Hull, 2015,
S. 59)
Zur besseren Verdeutlichung der GeschĂ¤ftsidee wurde ein BPMN-Diagramm erstellt.
Nachfolgend werden Ausschnitte dieses Diagramms erlĂ¤utert. Das gesamte Diagramm ist im

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

54

Anhang N zu finden. Beim BPMN-Diagramm, ebenso wie beim spĂ¤teren Prototyp ist der Fokus
auf eine protypische Implementierung gelegt. Daher werden etwaige SonderfĂ¤lle wie die
Ablehnung des Vertragsangebots von einer Partei oder das Ausbleiben der Initial Margin nicht
berĂźcksichtigt.
Im ersten Abschnitt wird das Zustandekommen des Clearingvertrages beschrieben. Da bei
einem Smart Contract keine zentrale Instanz vorhanden ist, muss das Erstellen des
Clearingvertrags von einer der beiden Parteien Ăźbernommen werden. Zur Vereinfachung des
Ablaufs soll der Vertrag immer vom KĂ¤ufer eines Wirtschaftsgutes erstellt werden.
Nach der Erstellung des Contracts werden beide Parteien zum Einzahlen der Initial Margin
aufgefordert. Sobald die Initial Margin von beiden Parteien eingezahlt wurde beginnt der
eigentliche Prozess des Clearings, welcher im nĂ¤chsten Abschnitt dargestellt wird.

Abbildung 19: BPMN-Diagramm des GeschĂ¤ftsvorfalls Abschnitt 1

Der zweite Abschnitt beginnt damit, dass das Clearing tĂ¤glich angestoĂen wird. Der
zugeklappte Unterprozess âAusgleich der Konten (Clearing)â wird im nachfolgenden Abschnitt
detailliert erlĂ¤utert. Nach dem Ausgleich der Konten wird geprĂźft, ob der Kontostand von
einer der beiden Vertragsparteien unterhalb der Maintenance Margin liegt. Ist dies der Fall,
so wird die Partei zu einem Margin Call aufgefordert. Die aufgeforderte Partei muss
entscheiden, ob sie der Aufforderung nachkommt oder die Frist verstreichen lĂ¤sst. Sollte es
zu keiner Aufforderung zum Zahlen einer Margin kommen oder die Margin wird fristgerecht
bezahlt, so wird gegen Ende dieses Ausschnitts geprĂźft, ob das Enddatum des Kontraktes
erreicht wurde. Ist das Enddatum noch nicht erreicht wird der Teilausschnitt am nĂ¤chsten Tag

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

55

wiederholt. Ist das Enddatum erreicht oder einem Margin Call wird nicht nachgekommen, so
wird das Clearing beendet und der KĂ¤ufer und der VerkĂ¤ufer ausbezahlt. Dies wird im 3.
Abschnitt besprochen.

Abbildung 20: BPMN-Diagramm des GeschĂ¤ftsvorfalls Abschnitt 2

In diesem Abschnitt wird der zugeklappte Unterprozess âClearingâ beschrieben. ZunĂ¤chst
muss der Smart Contract die Marktdaten des entsprechenden Wirtschaftsgutes von einem
externen Markdaten Provider beziehen. Daraufhin wird die Ănderung der Marktdaten zum
Vortag berechnet. FĂźr die Berechnung wird folgende Formel verwendet:

Î=(KG-KPt-1)-(KG-KPt)
Î = Ănderung
KG= KontraktgrĂśĂe
KPt= Kontraktpreis am Tag t

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

56

Ist die Ănderung positiv, so wird das Margin Konto des KĂ¤ufers um den Ănderungsbetrag
reduziert und das Konto des VerkĂ¤ufers um denselben Betrag erhĂśht. Bei einer negativen
Ănderung wird das Konto des VerkĂ¤ufers um den Ănderungsbetrag reduziert und das des
KĂ¤ufers um den Betrag erhĂśht. Nach diesem Schritt ist der Unterprozess des Clearings
beendet.

Abbildung 21: Clearing im Smart Contract

Im letzten Abschnitt wird, bevor das Settlement erfolgt, noch geprĂźft, ob einer der beiden
KontostĂ¤nde im negative Bereich ist. Ist das der Fall, so muss der Kontostand der anderen
Partei um diesen Betrag reduziert werden. Siehe zu diesem Sonderfall auch den Abschnitt
âAbsicherung bei starken KursverĂ¤nderungenâ im Kapitel 5.3. Der Aufgeklappte Unterprozess
âprĂźfe KontostĂ¤ndeâ befindet sich im Anhang O.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

57

Abbildung 22: BPMN-Diagramm des GeschĂ¤ftsvorfalls Abschnitt 3

5.3

Rechtliche und praktische EinschrĂ¤nkung

Die VolatilitĂ¤t der zum Clearing eingesetzten KryptowĂ¤hrung
Beim Clearing mit einem Smart Contract mĂźssen Gegenwerte im Smart Contract hinterlegt
werden. Diese Gegenwerte sind bei Smart Contracts typischerweise KryptowĂ¤hrungen, wie
die in Kapitel 2.1 genannten Bitcoin oder die fĂźr Smart Contract Plattform Ethereum
geschaffenen Ether. Diese KryptowĂ¤hrungen unterliegen zum jetzigen Zeitpunkt groĂen
Kurschwankungen. Betrachtet man den Wechselkurs zwischen Bitcoin und Euro der letzten 90
Tage (bezogen auf den 26.01.2016), so lag der Minimalwert der Zeitspanne am 28. Oktober
2015 bei 277,90 âŹ fĂźr einen Bitcoin. Der Maximalwert wurde am 18. Dezember 2015 mit
426,78 âŹ fĂźr einen Bitcoin erreicht. Dies entspricht einer maximalen KursĂ¤nderung von
53,57 %. (CoingeckoA)
Ăhnliche Beobachtungen kĂśnnen bei der Betrachtung des Wechselkurses zwischen Euro und
Ether gemacht werden. Hier wurde der Maximalwert der letzten 90 Tage (bezogen auf den
26.01.2016), am 26. Januar 2016 mit 2,54 âŹ fĂźr einen Ether erzielt. Der Minimalwert der
Zeitspanne betrug am 09. Dezember 2015 0,72 âŹ fĂźr einen Ether. Dies entspricht einer
maximalen KursĂ¤nderung von 352,78 %. (CoingeckoB)

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

58

Diese stark volatilen KryptowĂ¤hrungen sind ungeeignet, um als Gegenwert beim Clearing
eingesetzt zu werden, da genau durch das Clearing von DerivatvertrĂ¤gen Schwankungen in
Marktpreisen ausgeglichen werden sollen.
Da es sich bei der Entwicklung des Prototyps um eine Machbarkeitsstudie handelt, kann dieser
Aspekt vernachlĂ¤ssigt werden. Sollte es zu einer praktischen Umsetzung kommen, so sollte
geprĂźft werden, ob die MĂśglichkeit besteht, weniger volatile Gegenwerte im Smart Contract
zu hinterlegen.
Absicherung bei starken KursverĂ¤nderungen
Der auf einen Smart Contract Ăźbertragene GeschĂ¤ftsvorfall entspricht einem auĂerbĂśrslichem
(Over the Counter) gehandeltem Forward, bei welchem das Kreditrisiko auf eine zentrale
Clearingstelle Ăźbertragen wird (Hull, 2015, S. 61). Im Falle einer starken KursverĂ¤nderung kann
es dazu kommen, dass das Margin Konto einer Partei in den negativen Wertebereich gerĂ¤t.
Sollte die betroffene Partei daraufhin ihrer Zahlungsverpflichtung in Form eines Margin Calls
nicht nachkommen, so besteht fĂźr die Clearingstelle die Pflicht die andere Partei aus eigenen
Mitteln zu bezahlen (Hull, 2015, S. 59). In diesem Fall ist die zentrale Clearingstelle ein Smart
Contract und keine eigenstĂ¤ndige juristische Person, welche Ăźber ein eigenes VermĂśgen
verfĂźgt (Berwanger). Daher bleibt bei der Ăbertragung des GeschĂ¤ftsvorfalls in einen Smart
Contract ein gewisses Kreditrisiko bestehen.
Meldepflicht fĂźr DerivatvertrĂ¤ge
Nach Artikel 9 Absatz 1 der europĂ¤ischen Verordnung Nr. 648/2012 mĂźssen Derivatkontrakte
bei Abschluss, Ănderung oder Beendigung an ein registriertes und anerkanntes
Transaktionsregister gemeldet werden. Auf diese Verpflichtung wird bei der prototypischen
Entwicklung ebenfalls nicht eingegangen, da Ăźber den Prototyp nie reale DerivatvertrĂ¤ge
abgewickelt werden sollen.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

6

SEITE

59

Smart Oracles

Als Vorarbeit zur Umsetzung des GeschĂ¤ftsvorfalles mit einem Smart Contract, muss die
Besonderheit betrachtet werden, dass Smart Contracts ein in sich geschlossenes System sind
und keine Verbindung zur AuĂenwelt aufbauen kĂśnnen.
In diesem Kapitel wird zunĂ¤chst die Problemstellung erlĂ¤utert und daraufhin verschiedene
LĂśsungsansĂ¤tze vorgestellt. Eine prototypische Implementierung eines Smart Oracles erfolgt
in Kapitel 7.3 im Rahmen der Gesamtimplementierung des GeschĂ¤ftsvorfalls.
6.1

Problemstellung

Smart Contracts kĂśnnen von sich aus keine Verbindung zur AuĂenwelt aufbauen und daher
auch keine externen APIs von Marktdatenprovider wie der EuropĂ¤ischen Zentralbank,
Onvista.com oder Yahoo Finance ansprechen. Die einzige MĂśglichkeit externe Daten in die
geschlossenen Blockchain zubekommen, besteht darin, die Smart Contracts innerhalb der
Blockchain Ăźber Transaktionen anzusprechen (Ethereum, 2015).
Die naheliegende LĂśsung fĂźr den in Kapitel 5 gewĂ¤hlten GeschĂ¤ftsvorfall wĂ¤re es, eine der
beiden Vertragsparteien mit der Versorgung der Marktdaten Ăźber Transaktionen zu betrauen.
Dies wĂźrde jedoch bedeuten, dass diese Partei groĂe Macht besitzt, den Kontrakt zu ihren
Gunsten zu manipulieren. Daher scheidet dieser einfache Ansatz aus.
Die Erweiterung des ersten Ansatzes wĂźrde darin bestehen, dass beide Vertragsparteien den
Kontrakt mit Marktdaten Ăźber Transaktionen versorgen. Dies wĂźrde die Manipulation durch
eine der beiden Parteien verhindern. Jedoch wĂźrde dem Kontrakt die Entscheidungsgrundlage
fehlen, wenn die Marktdaten der beiden Parteien voneinander abweichen. Daher scheidet
diese MĂśglichkeit ebenfalls aus.
6.2

LĂśsungsansĂ¤tze

In der noch jungen Welt, der auf der Blockchain-Technologie beruhenden Smart Contracts,
hat sich der Begriff Smart Oracle etabliert wenn es darum geht, einen Zustand der realen Welt
in einen Smart Contract einflieĂen zulassen (Ripple Labs, 2014).
Smart Oracles ermĂśglichen es der streng deterministischen Blockchain Technologie nicht
deterministische UmweltzustĂ¤nde einflieĂen zu lassen. Da diese UmweltzustĂ¤nde, sobald sie
einmal in der Blockchain integriert sind, nicht mehr abĂ¤nderbar sind und streng
deterministisch weiterverarbeitet werden, muss einem Smart Oracle groĂes Vertrauen
entgegengebracht werden. (Ripple Labs, 2014)
Technisch gesehen ist ein Oracle ein einfacher Akteur, der wie die anderen Akteure,
Transaktionen auf der Blockchain durchfĂźhren kann. In diesen Transaktionen codiert das

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

60

Oracle die ZustĂ¤nde der realen Welt. Die eigentlichen Smart Contracts haben Zugriff auf diese
Daten sobald die Transaktion von der Blockchain verifiziert wurde, da alle Transaktionen auf
der Blockchain Ăśffentlich sind. Sieh dazu auch Kapitel 3.3.1.
Um das benĂśtigte Vertrauen fĂźr ein Oracle aufzubauen gibt es verschiedene AnsĂ¤tze. In den
nachfolgenden Unterkapiteln werden drei AnsĂ¤tze nĂ¤her betrachtet und die Vor- und
Nachteile der LĂśsungen aufgezeigt.
6.2.1 Distributed Oracles
Der erste Ansatz besteht, vereinfacht gesagt, darin nicht einem Smart Oracle zu vertrauen,
sondern darin die Daten von mehreren Oracles zu beziehen und die Mehrheitsentscheidung
der Oracles als Faktum anzuerkennen.
Das Startup-Unternehmen Orisi beschreibt in seinem auf Github verĂśffentlichen White Paper,
die Funktionsweise von Distributed Oracles detaillierter (Orisi, 2014). Das Whitepaper
beschreibt die Oracle Funktion fĂźr die Bitcoin Blockchain. Das Prinzip kann aber auch auf
andere Blockchain basierte Smart Contracts angewendet werden.
Bei diesem Prinzip verstĂ¤ndigen sich die Vertragsparteien eines Smart Contracts auf eine
Anzahl von Smart Oracles, welchen sie ein gewisses Vertrauen entgegenbringen. Die
gewĂ¤hlten Oracles versorgen den Smart Contract mit Daten aus der realen Welt. Der Smart
Contract entscheidet dann anhand von vorher festgelegten Regeln, wie mit den Oracle Daten
umgegangen wird. Diese Gestaltung dieser Regeln obliegt den Vertragspartnern des Smart
Contracts. Bei booleschen Werten kĂśnnten sich die Vertragsparteien zum Beispiel darauf
verstĂ¤ndigen, dass eine Einfache- oder eine Zweidrittelmehrheit erreicht werden muss, damit
der Wert als Faktum anerkannt wird. Bei Dezimalzahlen, wie sie etwa bei Kurswerten
auftreten, empfiehlt es sich nicht auf die Einfache- oder Zweidrittelmehrheit zu vertrauen, da
je

nach

Datenquelle

der

Oracles

leichte

Unterschiede,

insbesondere

in

den

Nachkommastellen, auftreten kĂśnnen9. Hier wĂźrde es sich empfehlen, den Mittelwert aus den
gelieferten Daten zu bilden. Um hier die groĂe Manipulation durch ein Oracle zu verhindern,
kĂśnnten der Maximal- und Minimalwert aus der Berechnung ausgeschlossen werden.
Der Vorteil des Distributed Oracles besteht darin, dass ein Single Point of Failure
ausgeschlossen wird. Es besteht nicht mehr die Gefahr, dass ein einzelnes Oracle gehackt wird,
fehlerhaft arbeitet, abgeschaltet oder bewusst manipuliert wird (Orisi, 2014).

9

Stichprobe zum Euro/Dollar Wechselkurs am 04.02.2016 um 13 Uhr: www.finanzen.net: 1,1174;
www.onvista.de: 1,1179; http://www.ariva.de: 1,11718

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

61

Als Schwierigkeit, bei der Verwendung von Distributed Oracles, kann die Einigung auf die
verwendeten Oracles zwischen den Vertragspartnern angesehen werden. Zum einen muss
sich erstmal eine gewisse Anzahl an Oracles am Markt etablieren. Momentan befinden sich
nur drei Oracles zu Testzwecken in der vom Startup Orisi betriebenen Liste (Orisi, 2016). Zum
anderen ist Manipulationsgefahr weiterhin hoch, wenn es einem Vertragspartner gelingt
Einfluss auf mehrere Oracles zu nehmen.
6.2.2 Reality Keys
Reality Keys ist ein Oracle Dienst der vom japanischen Unternehmen Social Minds Inc (KK)
betrieben wird (Reality KeysA). Reality Keys ist, wie Orisi, auf die Bitcoin Blockchain ausgelegt.
Es bietet aber auch eine Integration fĂźr andere Plattformen wie Ethereum und Eris an (Reality
KeysB).
Die Besonderheit bei Reality Keys ist, dass sie eine Mischform aus einem automatischen Oracle
und einem von Menschenhand kontrollierten Oracle betreiben. Im Normalfall arbeitet Reality
Keys wie ein normales Oracle, indem es die benĂśtigten Daten von einer Ăśffentlichen API
einflieĂen lĂ¤sst und innerhalb der Blockchain zur VerfĂźgung stellt. FĂźr diesen Normalfall
berechnet Reality Keys keine GebĂźhren. (Reality KeysA)
Sollten eine oder mehrere, der an dem Smart Contract beteiligten Parteien, Zweifel an der
Richtigkeit der vom Oracle Ăźbertragenen Werte haben, so kĂśnnen sie daraufhin eine
menschliche NachprĂźfung beauftragen. FĂźr die menschliche NachprĂźfung berechnet Reality
Keys eine GebĂźhr von 10 USD je zu prĂźfendem Wert. (Reality KeysC)
Das von Reality Keys angebotene Verfahren bietet den Vorteil, dass im Fall von falsch
bereitgestellten Werten einer externe API, nicht erreichbaren APIs oder Fehlern beim
Ăbertragungsweg eine menschliche NachprĂźfung beauftragt werden kann und der Smart
Contract nicht mit falschen Werten weiterarbeitet.
Nachteilig ist hingegen, dass der Smart Contract eine Art Fallback-Mechanismus
implementieren muss, der eingreift wenn ein Wert von einer der Vertragsparteien als falsch
deklariert wird und eine menschliche PrĂźfung beauftragt wird. Daneben sind die
Vertragspartner nicht dagegen geschĂźtzt, dass Reality Keys seinen Dienst einstellt, dass ein
Fehler bei der menschlichen PrĂźfung passiert oder es einem Vertragspartner gelingt den
Dienst von Reality Keys auf technische oder menschliche Weise zu manipulieren.
6.2.3 Oraclize
Oraclize ist ein Oracle-Dienst, welcher sich selber als nachprĂźfbar ehrlich bezeichnet. Diese
nachprĂźfbare Ehrlichkeit erreicht der Dienst durch die Verwendung von TLSNotary (Bertani,

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

62

2015). TLSNotary ist ein Dienst, welcher sich in den Verbindungsaufbau einer TLS-Verbindung
schaltet, um zu bestĂ¤tigen, dass ein bestimmter Server zu einem bestimmten Zeitpunkt
bestimmte Daten versendet hat (TLSNotary, 2015). Oraclize bietet zum Zeitpunkt der
Ausarbeitung eine Integration in die Bitcoin- und die Ethereum-Blockchain an.
Durch die Verwendung von TLSNotary erhĂśht das Oracle sein Vertrauensniveau. Eine
vollstĂ¤ndige Sicherheit bietet dieser Dienst jedoch auch nicht an, da Ă¤hnlich wie bei Reality
Keys die Gefahr besteht, dass Oraclize seinen Dienst einstellt oder das System gehackt wird.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

7

SEITE

63

Prototypische Implementierung des Smart Contracts

In den nachfolgenden Unterkapiteln wird die prototypische Implementierung des in Kapitel
5.2 entwickelten GeschĂ¤ftsvorfall beschrieben. Dazu wird zuerst eine benĂśtige Plattform fĂźr
Smart Contracts ausgewĂ¤hlt und deren Komponenten analysiert. AnschlieĂend wird auf die
Entwicklungsumgebung und -werkzeuge fĂźr Smart Contracts eingegangen. AbschlieĂend
werden die Anforderungen, Herausforderungen und die Umsetzung des Prototyps
beschrieben.
7.1

Auswahl von Smart Contract und DAPP-Plattform

Im Gegensatz zu reinen KryptowĂ¤hrung-Plattformen bieten Smart Contract bzw. DAPPPlattformen durch die AusfĂźhrung von Programmcode und Algorithmen mehr MĂśglichkeiten,
als nur den Transfer von virtuellem Geld. Nachfolgend werden die am Markt verfĂźgbaren
Plattformen analysiert und bewertet. AnschlieĂend wird eine Plattform festgelegt, auf die der
zuvor fachlich konzipierte GeschĂ¤ftsvorfall implementiert wird.
7.1.1 Plattformen
Anders als die Thematik um KryptowĂ¤hrungen sind Plattformen fĂźr Smart Contracts trotz der
zeitlich frĂźheren Idee als Bitcoin, noch ein recht neues Thema. Die Plattformen befinden sich
selbst noch in einem sehr frĂźhen Stadium, womit mit Fehlern und wenig optimierten
Umgebungen bzw. Workflows zu rechnen ist.
Ethereum
Das Projekt Ethereum ist eine von Vitalik Buterin 2013 entwickelte und 2014 von Gavin Wood
formal beschriebene Smart Contract bzw. DAPP-Plattform mit einer eigenen âTuringVollstĂ¤ndigenâ10 Programmiersprache (EthereumC, 2015), (Wood Dr., 2014). Zum
gegenwĂ¤rtigen Zeitpunkt befindet sich die Plattform noch in der Entwicklungsphase. Ein erstes
Release hat es Mitte 2015 mit âFrontierâ gegeben. Anders als bei der Bitcoin-Plattform ist es
mĂśglich, ausfĂźhrbaren Code ebenfalls durch Transaktionen in die Blockchain zu injizieren,
welcher von den Knoten im Netzwerk aufgerufen werden kann. Diese Programme werden
durch eine Aktivierung mittels einer weiteren Transaktion von jedem beteiligen Knoten des
Netzwerkes in einer auf dem Knoten befindlichen Blockchain-basierten virtuellen Maschine,
der EVM, ausgefĂźhrt. DarĂźber hinaus sind in âEthereumâ auch finanzielle Transaktionen mit
der eigenen WĂ¤hrung âEtherâ mĂśglich. Daraus folgt, dass auf dieser Plattform ebenfalls

10

Turing-Complete bedeutet, dass der Algorithmus durch eine Turing-Maschine, z.B. ein Automat,
ausgefĂźhrt werden kann, http://c2.com/cgi/wiki?TuringComplete

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

64

finanzielle AnwendungsfĂ¤lle realisiert werden kĂśnnen. Weiteres zu diesem Konzept und den
Komponenten ist im Kapitel 7.1.3 beschrieben.
Eris Industries
Im Gegensatz zu âEthereumâ, verfolgt âEris Industriesâ den Ansatz, dass zu jeder DAPP eine
eigene, geschlossene Blockchain genutzt wird und nicht wie bei âEthereumâ, eine Blockchain
mit einem ausreichend groĂen Netzwerk an Knoten zur Validierung dahintersteht. Die
gesicherte Validierung der Transaktionen erfolgt bei âEris Industriesâ indirekt dadurch, dass
Ăźber eine Zugriffsschicht nur Berechtigten die Interaktion mit der Blockchain gestattet wird
(Eris Industries, 2016). Durch dieses Konzept wird die Blockchain-Technologie in ihrer reinen
Form als verteilte Datenbank mit Validierung und Speicherung von Transaktionen genutzt.
Codius
Das Projekt âCodiusâ ist eine ehemalige Plattform fĂźr das Hosting von DAPPs. Das Projekt wird
seit Mitte 2015 von der Firma Ripple Labs nicht weiterentwickelt (Maxim, 2015). Das Konzept
beinhaltet unter anderem die explizite Einbeziehung von Smart Oracles, also der Bezug von
externen Daten in der Blockchain und der Zugriff auf Dienste der AuĂenwelt. Die Abbildung
23 veranschaulicht dieses Konzept.

Abbildung 23: Konzept von Smart Oracles nach Codius11

Bitcoin
Die bekannteste Plattform fĂźr KryptowĂ¤hrung ist zur Implementierung und Nutzung von
Smart Contracts nicht ausgelegt. Zwar bietet Bitcoin ebenfalls eine Skriptsprache, welche aber
im

Gegensatz

zu

âEthereumâ

EinschrĂ¤nkungen

bezĂźglich

der

AusfĂźhrung

und

NutzungsmĂśglichkeiten mit sich bringt. Es sind keine PrĂźfungen oder die AusfĂźhrung von
zusĂ¤tzlicher Logik mĂśglich (Bitcoinwiki-M, 2016). Eine weitere EinschrĂ¤nkung ist, dass die

11

Entnommen aus Plattformsicherheit - Smart Contracts und TPM, Abbildung 1.1 von Christof Graff,
Matthias Zscherp, Helmut Stoiber,entwickler.press, 2015

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

65

Block Size auf nur einem Megabyte gesetzt ist, was die Speicherung von internen Werten und
Quellcode eines Smart Contracts einschrĂ¤nkt (Bitcoinwiki-N, 2016).
7.1.2 Auswahl der Smart Contract-Plattform
Als Smart Contract bzw. DAPP-Plattform ist das Projekt âEthereumâ ausgewĂ¤hlt worden. Zum
einen durch die Vielzahl an Projekten und Start-Ups sowie der GrĂśĂe der Community, zum
anderen soll in der vorliegenden Arbeit der Fokus nicht auf eine geschlossene Blockchain wie
bei âEris Industriesâ gelegt werden, sondern auf eine berechtigungslose Blockchain bei der
jeder mitwirken kann. AuĂerdem sind die Plattformen âCodiusâ trotz des nĂźtzlichen Konzepts,
aber aufgrund der fehlenden Weiterentwicklung, als auch die Bitcoin-Plattform, wegen der
fehlenden FunktionalitĂ¤t, nicht weiter in Betracht gezogen worden.
7.1.3 Aufbau und Komponenten von Ethereum

Abbildung 24: Ethereum Technologie Stack12

MIST Browser
Der MIST Browser ist eine sich in der Entwicklung befindliche grafische OberflĂ¤che zur
Benutzung von DAPPs. Daneben bietet er die Funktion einer Wallet zur Verwaltung der

12http://image.slidesharecdn.com/ethereum-stephantual-pres-8-150310095125-conversion-

gate01/95/ethereum-paris-w-stephan-tual-17-638.jpg?cb=1425981727

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

66

WĂ¤hrung âEtherâ an. Das Programm basiert auf der Meteor-Plattform und wird als
eigenstĂ¤ndige, dezentrale Anwendung von einem Benutzer ausgefĂźhrt (EthereumE, 2015).
Ethereum Virtual Machine - EVM
Die Ethereum Virtual Machine, kurz EVM, ist eine verteilte virtuelle Maschine, die im Client
auf jeden Knoten des Ethereum-Netzwerk betrieben wird. Diese dient sowohl der AusfĂźhrung
eines kompilierten Smart Contracts, als auch der Verwaltung eines internen Zustands von
Objekten sowie einer Kopie der Blockchain auf einem Knoten. Dabei ist zu erwĂ¤hnen, dass die
EVM eine âTuring-VollstĂ¤ndigeâ Programmiersprache besitzt, die dazu dient, Smart Contracts
auszufĂźhren, um den Zustand der EVM, als auch von Objekten zu Ă¤ndern. Wird eine Funktion
eines Smart Contracts aufgerufen, so hat dies zur Folge, dass alle Knoten des EthereumNetzwerks diese ausfĂźhren. Bei grĂśĂeren Operationen kann dies unter UmstĂ¤nden zu einem
Engpass und so zu einem Effizienzproblem fĂźhren. Daher ist es zum gegenwĂ¤rtigen Zeitpunkt
empfehlenswert, nur kleine Operationen in einem Smart Contract auszufĂźhren (EthereumD,
2015).
Clients
Zur Interaktion mit dem Netzwerk stehen dem Benutzer verschiedene Clients in
verschiedenen Programmiersprachen zur VerfĂźgung. Die Funktionsweise und die
bereitgestellten Funktionen sind gleich. Die meisten Implementierungen sind als KonsolenAnwendungen realisiert.
Das Programm âEthâ ist ein in C++ geschriebener Client, welcher ebenfalls als Grundlage fĂźr
den Client âAlethZeroâ dient. âAlethZeroâ bietet, anders als âEthâ, eine grafische
BenutzeroberflĂ¤che zur Interaktion mit dem Ethereum-Netzwerk an.
Daneben gibt es den in Python implementierten Client âPyEthereumâ. Auch dieser Client stellt
wie âEthâ die gleichen Funktionen, wie z.B. eine JSON-RPC-Schnittstelle fĂźr DAPPs zur
Interaktion mit âEthereumâ, bereit.
Als letztes sei der Client âGethâ erwĂ¤hnt. Dieser Client ist in Golang realisiert und ist eine
leichtgewichtige Anwendung zur Interaktion mit dem Ethereum-Netzwerk. Eine weitere
vorteilhafte Eigenschaft von âGethâ ist die interne Nutzung der JavaScript API âWeb3â
innerhalb der âGethâ-Konsole (EthereumD, 2015). Daraus ergeben sich Synergieeffekte bei
der Entwicklung der DAPP, welche ebenfalls auf dieser API zur Interaktion mit dem EthereumNetzwerk aufbaut. Aus diesem Grund wird der âGethâ-Client in der Version 1.4.0-stable als
JSON-RPC-Schnittstelle und Ăbermittler der Befehle aus der DAPP zur Kommunikation mit
âEthereumâ genutzt.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

67

Die in Abbildung 24 zusĂ¤tzlich dargestellten Komponenten Swarm13, ein verteiltes
Dateisystem zur Speicherung von Daten und Whisper14, das interne Kommunikationsprotokoll
zum Austausch von Informationen zwischen Smart Contracts bzw. DAPPs, werden aufgrund
der geringen Relevanz fĂźr die prototypische Implementierung des GeschĂ¤ftsvorfalls nicht
nĂ¤her betrachtet.
7.1.4 Interkation mit dem Ethereum-Netzwerk und dem Smart Contract

Abbildung 25: Interkation mittels DAPP und Ethereum-Netzwerk

Ein Benutzer kann mit dem Ethereum-Netzwerk und damit auch der Smart Contract Ăźber die
zuvor beschriebenen Clients oder einer DAPP kommunizieren. ZukĂźnftig soll es ebenfalls
mĂśglich sein, dass die Interaktion mit Instanzen von Smart Contracts mit einem eigens dafĂźr

13

Swarm, https://github.com/ethereum/go-ethereum/wiki/Swarm---distributed-preimage-archive

14

Whisper, https://github.com/ethereum/wiki/wiki/Whisper

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

68

entwickelten Browser, dem MIST Browser, erfolgen kann. Zum gegenwĂ¤rtigen Zeitpunkt
befindet sich dieser noch in der Entwicklung (siehe Kapitel 7.1.3, MIST Browser).
Im Gegensatz zum Entwickler, ist die Idee fĂźr den Nutzer, dass dieser Ăźber einen Browser
mittels des HTTP-Protokolls auf eine DAPP zugreifen kann. Diese reprĂ¤sentiert dabei das
Frontend und bildet die Schnittstelle zur Interaktion mit dem dahinterliegenden Smart
Contract, welcher das Backend reprĂ¤sentiert. Im Gegensatz zu nativen Clients, wie z.B. âEthâ
oder âGethâ ist eine direkte Kommunikation mit dem Ethereum-Netzwerk nicht mĂśglich. Als
Kommunikationsschnittstelle muss daher im Hintergrund ein entsprechender nativer Client
gestartet werden. Dieser wird durch die DAPP mittels der JavaScript-API âWeb3â, welche von
Ethereum entwickelt wird, durch JSON-RPC-Aufrufen angesprochen. Dadurch werden die
Befehle von der DAPP durch den nativen Client an das Ethereum-Netzwerk gesendet und
RĂźckmeldungen durch Callback-Methoden entgegengenommen. Durch die Verbindung
zwischen dem Client und der JavaScript-API ist es mĂśglich, sĂ¤mtliche FunktionalitĂ¤ten, die mit
dem nativen Client mĂśglich sind auch Ăźber die DAPP auszufĂźhren.
7.2

Werkzeuge und Plattformen

7.2.1 Programmiersprachen
Sowohl fĂźr den Smart Contract, als auch fĂźr die DAPP werden unterschiedliche
Programmiersprachen bzw. Mark-Up-Sprachen verwendet. Die Sprachen fĂźr das Frontend
stammen aus dem Bereich der Web-Entwicklung.
Smart Contract
Ein Smart Contract kann in verschiedenen Programmiersprachen implementiert werden.
Unter anderem ist es mĂśglich, diese in Serpant, LLC, Mutan oder Solidity zu schreiben. Allen
Programmiersprachen ist gemein, dass der Quellcode zu einem Kompilat Ăźbersetzt werden
muss und nicht wie bei Skriptsprachen interpretiert wird, obwohl die jeweiligen Sprachen der
Syntax von bekannten Skriptsprachen Ă¤hnlich sind.
Die in âEthereumâ am meisten angewandte Programmiersprache zur Erstellung von Smart
Contracts ist âSolidityâ. Daneben gibt es in diesem noch recht jungen Umfeld Beispiel Kontrakte

in

der

Sprache

âSerpantâ. Aufgrund

der

zahlreichen

Beispiele

und

Dokumentationen der Ethereum-Community wird âSolidityâ zur Implementierung des Smart
Contracts fĂźr den entwickelten GeschĂ¤ftsvorfall verwendet.
Solidity ist wie Java eine High Level - Programmiersprache. Zum gegenwĂ¤rtigen Zeitpunkt
befindet sie sich in der Entwicklung und liegt in der Version 0.20 vor (EthereumH, 2015).
Aufgrund dessen sind Style Guides und Entwicklung - Patterns einem starken Wandel
ausgesetzt. Sie ist stark an der Syntax von JavaScript orientiert, wodurch sich bei der

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

69

Entwicklung der DAPP und des Smart Contracts Synergieeffekte nutzen lassen. Dies ist
ebenfalls ein ausschlaggebendes Kriterium, um âSolidityâ zur Implementierung des Smart
Contracts zu verwenden.
DAPP
Eine dezentralisierte Applikation ist, wie bereits in Kapitel 2.2 erwĂ¤hnt, eine auf WebTechnologien basierende Anwendung. Aus diesem Grund werden die zur Entwicklung von
Web-Anwendungen Ăźberwiegend genutzten Programmier- und Mark-Up Sprachen
verwendet. Dazu zĂ¤hlen fĂźr die Struktur der Anwendung HTML5, fĂźr das Design CSS und fĂźr
ein dynamisches Verhalten und zur Interaktion JavaScript (Johnston, et al., 2014).
7.2.2 Entwicklungswerkzeuge
Entwicklungsumgebungen und Editoren
FĂźr die Entwicklung von Smart Contracts bzw. DAPPs fĂźr Ethereum kĂśnnen verschiedene
speziell dafĂźr entwickelte Werkzeuge wie âMixâ, aber auch aus der Web-Entwicklung
bekannte erweiterte Texteditoren, wie z.B. âNotepad++â oder âSublimeâ, verwendet werden.
Die Entwicklungsumgebung âMixâ ist eine sich in der Entwicklung befindliche IDE aus dem
Projekt Ethereum. Neben den bekannten Entwicklungsfunktionen bietet sie spezielle
Funktionen fĂźr das Debugging von Smart Contracts an. Dazu gehĂśrt das Erstellen von
Szenarien, welche eine Test-Blockchain in einen bestimmten Zustand zur Interaktion mit dem
Smart Contract versetzt. Dabei verwendet âMixâ den Client âEthâ als Grundlage zur Interaktion
mit der Blockchain (EthereumF, 2015).
Daneben ist es mĂśglich, die Entwicklung und die Programmierung eines Smart Contracts bzw.
einer DAPP in âNotepad++â bzw. âSublimeâ vorzunehmen. Im Gegensatz zu Mix muss dabei
das Deployment und Debugging manuell Ăźber einen der Clients erfolgen. Zur UnterstĂźtzung
dieser Vorgehensweise sind ebenfalls Entwicklungs-Frameworks verfĂźgbar, welche diese
Prozesse erleichtern. Diese Frameworks werden in Kapitel 7.2.3 evaluiert.
Aufgrund der einschlĂ¤gigen Erfahrung mit âSublimeâ, der erhĂśhten Einarbeitungszeit bei der
Verwendung sowie dem Entwicklungsstatus von âMixâ wird zur Entwicklung des Smart
Contracts bzw. der DAPP âSublimeâ (Build 3083) in Kombination mit dem âGethâ-Client
verwendet.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

70

7.2.3 Frameworks
Zur UnterstĂźtzung der Entwicklung der DAPP werden die Frameworks âMeteorâ, âEmbarkâ
und âTruffleâ betrachtet. Hier ist anzumerken, dass âMeteorâ mehr FunktionalitĂ¤t bietet als
nur fĂźr eine DAPP fĂźr âEthereumâ. Dieses Framework zur Entwicklung von auf JavaScriptbasierenden Web-Anwendungen ist generisch gehalten und wird fĂźr dezentralisierte
Applikation aller Art verwendet. Im Gegensatz dazu sind die Frameworks âEmbarkâ und
âTruffleâ speziell fĂźr die Entwicklung von DAPPs fĂźr âEthereumâ entwickelt worden. Beide
Frameworks sind sich aufgrund dessen Ă¤hnlich.
Bewertung der Frameworks
Die Frameworks sind unter Beachtung der fĂźr die Entwicklung relevanten Kriterien nĂ¤her
analysiert worden. Die Ergebnisse der Analyse werden im Anhang K dargestellt. Die dort
abgebildete Matrix bildet die Grundlage fĂźr die Auswahl eines Frameworks fĂźr die
Entwicklungs- und Laufzeitumgebung.
Auswahl von Frameworks
Aufgrund der teilweise engen Verzahnung von âEmbarkâ mit âMeteorâ werden beide
Frameworks bzw. Applikationsplattformen fĂźr die DAPP genutzt. Auf der einen Seite wird das
erleichterte und automatisierte Deployment von Smart Contracts durch âEmbarkâ genutzt,
auf der anderen Seite die Erweiterbarkeit der webbasierten DAPP durch eine groĂe Anzahl an
verfĂźgbaren Meteor-Paketen. Dabei ist zu erwĂ¤hnen, dass âEmbarkâ ausschlieĂlich zum
initialen Aufsetzen der DAPP genutzt wird. Das erneute Deployment eines Smart Contracts
nach Ănderung wird manuell Ăźber den âGethâ-Client vollzogen. Dies ist damit begrĂźndet, dass
es in der vorliegenden Entwicklungsumgebung zu einem fehlerhaften Auslesen der Parameter
fĂźr den Smart Contract in âEmbarkâ gekommen ist. Somit ist ein automatisiertes Deployment
nicht mĂśglich gewesen.
7.2.4 Laufzeitumgebung
Die Laufzeitumgebung der DAPP basiert auf âMeteorâ (Version 1.2.1). Dies ist wie bereits
erwĂ¤hnt ein Framework zur Entwicklung von JavaScript-basierten Web-Anwendungen. Aus
diesem Grund nutzt Meteor zur AusfĂźhrung der DAPPs im Hintergrund Node.js. Node.js ist
eine serverseitige Anwendungsplattform zum Betreiben von Web-Anwendungen, welche in
JavaScript geschrieben worden ist. Dadurch ist es mĂśglich, leichtgewichtige Webserver und

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

71

damit ebenfalls DAPPs zu realisieren. Als ausfĂźhrende JavaScript-Engine wird die von Google
entwickelte Laufzeitumgebung âV8â verwendet15.
7.3

Prototypische Umsetzung des Smart Oracles

FĂźr die protypische Umsetzung des in Kapitel 5.2 gewĂ¤hlten GeschĂ¤ftsvorfalls ist in Kapitel
7.1.2 ein Smart Contract in der Ethereum Blockchain gewĂ¤hlt worden. FĂźr die Umsetzung des
GeschĂ¤ftsvorfalls in einen in der Ethereum Blockchain gehosteten Smart Contract, wird ein
weiterer Prototyp benĂśtigt. Der Prototyp eines Smart Oracles, um den Smart Contract mit
Marktdaten versorgen zu kĂśnnen.
Die Entscheidung einen eigenen Prototyp zu entwickeln und nicht auf eine der in Kapitel 6.2
genannten LĂśsungen zurĂźckzugreifen ist darin begrĂźndet, dass sich die vorgestellten
LĂśsungen primĂ¤r an die Bitcoin Blockchain richten oder nur eine Integration in die Ăśffentliche
Ethereum-Blockchain und nicht in eine private Ethereum-Test-Blockchain anbieten. Daneben
bietet eine eigene Implementation mehr FlexibilitĂ¤t, insbesondere im Hinblick auf die externe
Datenversorgung und das Testen der Implementierung.
7.3.1 Funktionale Anforderung
Die hier genannten funktionalen Anforderungen und im folgenden Unterkapitel genannten
nicht-funktionalen Anforderungen sind aus den BedĂźrfnissen des Smart Contracts an die
Marktdatenversorgung und den MĂśglichkeiten sowie EinschrĂ¤nkungen der eingesetzten
Technologie Ethereum abgeleitet worden.
Registrieren eines Smart Contracts
Der Smart Contract, welcher mit Marktdaten versorgt werden will, muss die MĂśglichkeit
besitzen sich am Oracle Contract zu registrieren und die fĂźr die Marktdatenversorgung
benĂśtigten Ether zu Ăźberweisen.
Abmelden eines Smart Contracts
Ein mit Marktdaten versorgter Smart Contract muss die MĂśglichkeit haben, die
Marktdatenversorgung durch den Smart Oracle Contract abzubestellen und die nicht
verwendeten Ether zurĂźckzuerhalten.

15

https://nodejs.org/en/docs/es6/

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

72

RegelmĂ¤Ăige Marktdatenversorgung
Der registrierte Smart Contract muss in einem zu definierenden Intervall mit realen
Marktdaten versorgt werden.
Abrechnung der Dienstleistung
Das Smart Oracle muss dem registrierten Contract marktgerechte GebĂźhren fĂźr die
Bereitstellung der Marktdaten und das Aufrufen von Funktionen berechnen.
7.3.2 Nicht-funktionale Anforderungen
Modularer Aufbau
Der zu entwickelnde Prototyp soll nach MĂśglichkeit modular aufgebaut werden, um so eine
einfache Wiederverwendbarkeit der Module in anderen Projekten zu ermĂśglichen. Daneben
sollen die Datenquellen mĂśglichst einfach austauschbar sein, um theoretisch eine mĂśglichst
groĂe Anzahl an Marktdaten anbieten zu kĂśnnen und nicht an einen Anbieter gebunden zu
sein.
VertrauenswĂźrdige Datenquellen
Die Marktdaten sollen von Institutionen bezogen werden, welchen allgemein ein groĂes
Vertrauen entgegengebracht wird.
Robustheit
Etwaige Fehler im Prozess der Marktdatenversorgung soll der Prototyp nach MĂśglichkeit
selber kompensieren. Nicht kompensierbare Fehler sollen auf der Konsole bzw. einer LogDatei ausgegeben werden.
7.3.3 Konzeption des Smart Oracles
Die Konzeption des Smart Oracles unterteilt sich in zwei Bereiche. Zum einen muss das
eigentliche Oracle als Java-Anwendung entwickelt werden. Zum anderen soll ein Oracle
Contract entwickelt werden, welcher die neuen Marktdaten des eigentlichen Oracles
entgegennimmt und an den Smart Contract weiterreicht. Dieser Zwischenschritt erhĂśht die
ModularitĂ¤t der Gesamtanwendung, da das Oracle so nicht nur fĂźr den einen Anwendungsfall
genutzt werden kann, sondern fĂźr mehrere unterschiedliche Smart Contracts.
Das nachfolgende BPMN-Diagramm soll den Prozessablauf des Smart Oracles und das
Zusammenspiel zwischen den EntitĂ¤ten verdeutlichen. Ein vergrĂśĂerte Darstellung befindet
sich in Anhang P.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

73

Abbildung 26: Prozessablauf Smart Oracle

Der dargestellte Prozess beginnt aus der Sicht des Oracles damit, dass ein Smart Contract sich
am Oracle Contract registriert und Ether fĂźr die Dienstleistung des Oracles Ăźberweist. Der
Oracle Contract registriert daraufhin den Contract und verbucht die erhaltenen Ether intern.
Nach der PrĂźfung, ob genĂźgend Ether vorhanden sind, wartet der Oracle Contract darauf, ob
neue Marktdaten von der Java-Anwendung bereitgestellt werden oder sich der registrierte
Smart Contract wieder abmeldet. Kommt es aufgrund von einer selbst gewĂ¤hlten Abmeldung
des Contracts oder aufgrund von nicht genĂźgend vorhandener Ether zu einer Abmeldung des
Contracts, so werden die verbleibenden Ether ausbezahlt und die Adresse des Smart Contracts
wird gelĂśscht. Sind genĂźgend Ether vorhanden und es treffen neue Marktdaten von der JavaAnwendung ein werden diese an den registrierten Smart Contract weitergereicht. Danach
beginnt der Prozessabschnitt mit der PrĂźfung des Etherkontostandes erneut.
Der Prozess der Java-Anwendung wird in einem definierten Zeitintervall automatisch
gestartet. Nach dem Start ruft die Anwendung externe Marktdaten von einem Dienstleister
ab und bereitet diese fĂźr die Verwendung in einem Smart Contract auf. Danach erfolgt die
eigentliche Ăbertragung der Marktdaten an den Oracle Contract. Nach einer Wartezeit von
einer Minute erfolgt eine ĂberprĂźfung, ob die Ăźbertragenen Daten im Oracle Contract richtig

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

74

gesetzt wurden. Sollten die Daten nicht richtig Ăźbertragen worden sein, so wird das Setzen
der Daten erneut angestoĂen.
7.3.4 Eingesetzte Technologien
FĂźr die Umsetzung des Smart Oracles werden die folgenden Technologien eingesetzt:
Java
FĂźr die Umsetzung des eigentlichen Oracles soll die Programmiersprache Java in der Version
8 verwendet werden. Die Programmiersprache Java wird als bekannt vorausgesetzt und an
dieser Stelle nicht weiter erlĂ¤utert. Als Build-Management-Tool wird Apache Maven in der
Version 3.3.3 eingesetzt.
Ethereum/Solidity
FĂźr die Implementierung des Oracle Contracts wird die fĂźr Ethereum entwickelte
Programmiersprache Solitity eingesetzt. Eine detaillierte Beschreibung zu Ethereum und der
Programmiersprache Solidity ist in Kapitel 7.2 zu finden.
Geth
FĂźr die Kommunikation mit der Ethereum Blockchain und somit auch dem Oracle Contract
wird ein Geth-Client eingesetzt. Eine Beschreibung zu Geth befindet sich ebenfalls in Kapitel
7.2.
JSON-RPC
Die Kommunikation zwischen der Java-Anwendung und dem Geth-Client erfolgt Ăźber Remote
Procedure Calls (RPC), welche vom Geth-Client bereitgestellt werden. Als Datenformat
akzeptiert der Geth-Client das JSON-Datenformat.
7.3.5 Datenquelle
Als vertrauenswĂźrdige Datenquelle wird die an allen Handelstagen bereitgestellten XML-Datei
der EuropĂ¤ischen Zentralbank verwendet, welche alle bedeutenden Wechselkurse gegenĂźber
dem Euro enthĂ¤lt (EuropĂ¤ische Zentralbank). Der modulare Aufbau soll aber einen Austausch
der Datenquelle ermĂśglichen.
7.3.6 Umsetzung
Die Betrachtung der Umsetzung erfolgt in zwei Teilen. ZunĂ¤chst wird der in Solidity
geschriebene Oracle Contract betrachtet. Im zweiten Teil wird dann auf das eigentliche Oracle
als Java-Anwendung eingegangen.
Oracle Contract

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

75

Aufgrund der geringen GrĂśĂe des Oracle Contracts wird an dieser Stelle der Quellcode
komplett dargestellt und erlĂ¤utert. Eine Abstrahierung ist daher nicht notwendig.

Abbildung 27: Quellcode Oracle Contract

Im obersten Abschnitt des Oracle Contracts sind die Variablendeklaration zu finden. Ăber die
oracleAddress wird festgelegt, von welchem Oracle der Oracle Contract Marktdatenupdates
entgegennimmt. In den Variablen registeredContract und registeredContractBalance werden
spĂ¤ter die Adresse und der Kontostand des registrierten Smart Contracts gespeichert. Die
Variable ch vom Typ Clearinghouse ist notwendig, damit der Oracle Contract im spĂ¤teren

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

76

Verlauf eine Funktion beim registrierten Contract aufrufen kann, um so das Update der
Marktdaten durchzufĂźhren. In der Variable currentValue wird der aktuelle Wert des
Marktdatums festgehalten. UpdateTime speichert die zugehĂśrige Aktualisierungszeit.
Die HauptfunktionalitĂ¤t findet in der Funktion set statt. Sie wird von der Java-Anwendung
aufgerufen und bekommt das aktuelle Marktdatum Ăźbergeben. Nach dem Aufrufen wird
zunĂ¤chst die Variable ch mit der Adresse des registrierten Contracts befĂźllt. Dies ist
notwendig, damit im weiteren Verlauf die Funktion updateMarketPrice() am richtigen Smart
Contract aufgerufen wird. Mit der if-Funktion wird sichergestellt, dass die Funktion nur vom
zuvor definierten Oracle aufgerufen werden kann. Ist dies sichergestellt, so werden der
aktuelle Wert und das Datum neu gesetzt. Daraufhin erfolgt, sofern der registrierte Contract
Ăźber genĂźgend Ether-Einlagen verfĂźgt, das Aufrufen der updateMarketPrice()-Funktion beim
registrierten Contract. An die Oracle Adresse werden die fĂźr die Transaktion berechnete Ether
Ăźberwiesen, da das aufrufende Oracle fĂźr die gesamte Transaktionskette

die

Transaktionskosten bezahlen muss. In der letzten Zeile der Funktion wird der Kontostand des
registrierten Contracts um den berechneten Wert reduziert.
Die Funktionen get() und getUpdateTime() sind Hilfsfunktionen um das aktuelle Marktdatum
und die Aktualisierungszeit auslesen zu kĂśnnen.
Ăber die Funktion register() kann sich ein Smart Contract registrieren und gleichzeitig die fĂźr
die Dienstleistung erforderlichen Ether Ăźberweisen. Die Funktion ist nur aufrufbar, wenn noch
kein Smart Contract registriert ist.
Ăber die Funktion unregister() kann sich der registrierte Contract wieder von der
Marktdatenversorgung

abmelden

und

erhĂ¤lt

seinen

verbleibenden

Kontostand

zurĂźckerstattet.
Java-Anwendung
Die Umsetzung der Java-Anwendung wird anhand des nachfolgenden Klassendiagrammes
erlĂ¤utert. Der vollstĂ¤ndige Quellcode befindet sich als Anhang Q.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

77

Abbildung 28: Klassendiagramm Oracle (Java-Anwendung)

Die Klasse App ist die ausfĂźhrbare Klasse der Anwendung. Ăber einen Ăbergabeparameter
kann der Intervall fĂźr die Marktdatenaktualisierung in Minuten festgelegt werden. In diesem
Zeitintervall wird die Klasse PriceUpdate wiederholt aufgerufen. Aus einer Properties Datei
liest die Klasse PriceUpdate die benĂśtigten Parameter fĂźr eine Marktpreisaktualisierung. Dies
sind: Die Adresse des absendenden Accounts, die Zieladresse des Oracle Contracts, die URL
unter welcher der RPC-Server erreichbar ist und die WĂ¤hrung des benĂśtigten Wechselkurses.
Ăber die boolesche Variable random kann festgelegt werden, ob die Klasse PriceUpdate die
Klasse ECBXML aufruft, um reale Marktdaten zu erhalten, oder die Klasse Random aufruft, um
Zufallswerte zum Testen zu erhalten.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

78

Vor dem eigentlichen Update des Oracale Contracts wird die Klassen JsonBuilder benĂśtigt. Sie
bekommt alle benĂśtigten Parameter Ăźbergeben, um den JSON-String zu erstellen. Hierzu
bildet sie mit Hilfe der Klasse Keccak16 den SHA3 Wert vom aufzurufenden Funktionsnamen
des Oracle Contracts und verwendet die ersten vier Byte des SHA3-Wertes fĂźr den JSONString. Des Weiteren Ăźbersetzt sie die Ăźbergebenen Dezimalwerte in das fĂźr den JSON-String
benĂśtigten Hexadezimalformat und fĂźllt den Hexadezimalwert mit Nullen auf 32 Byte auf. Alle
weiteren benĂśtigten Werte, wie die Methode, die Absenderadresse und die Zieladresse
werden ebenfalls in den JSON-String eingefĂźgt.
Die Klasse PriceUpdate baut daraufhin eine RPC-Verbindung zum Geth-Client auf und
ĂźbertrĂ¤gt den JSON-String zum Geth-Client. Hierdurch wird das aktuelle Marktdatum an den
Oracle Contract Ăźbergeben.
Nach einer Wartezeit von einer Minute wird durch den Aufruf der get()-Funktion beim Oracle
Contract ĂźberprĂźft, ob das aktuelle Marktdatum erfolgreich Ăźbertragen wurde. Sollte das
Marktdatum nicht erfolgreich Ăźbertragen worden sein, so wird der JSON-String erneut an den
Geth-Client gesendet.
Die wichtigsten Zwischenschritte und Ergebnisse werden zur besseren Nachvollziehbarkeit auf
der Konsole ausgegeben.
7.3.7 Kritische Reflexion und Ausblick
Die GrundfunktionalitĂ¤t eines Smart Oracles konnte mit diesem Prototyp erfolgreich
implementiert werden. Externe Marktdaten kĂśnnen persistent in der Ethereum-Blockchain
gespeichert werden und anderen Smart Contracts zur VerfĂźgung gestellt werden. Die in den
Kapiteln 7.3.1 und 7.3.2 definierten funktionalen und nicht-funktionalen Anforderungen
konnten vollstĂ¤ndig umgesetzt werden.
Ein erhĂśhtes Vertrauensniveau besitzt dieser Prototyp hingegen nicht, da keine der in Kapitel
6.2 vorgestellten Methoden zur VergrĂśĂerung des Vertrauens eingesetzt wurden. Vor einem
praktischen Einsatz sollten mehrere unabhĂ¤ngige Oracles entwickelt werden und/oder das
von oraclize.it vorgestellte kryptografisches BestĂ¤tigungsverfahren eingesetzt werden, um das
Vertrauen zu erhĂśhen.
Daneben sollte das Oracle zukĂźnftig so weiterentwickelt werden, dass mehrere
unterschiedliche Marktdaten gleichzeitig zur VerfĂźgung gestellt werden kĂśnnen und ebenfalls

16

Die Klasse Keccak ist nicht selber geschrieben und wurde vom Entwickler romus Ăźbernommen:
https://github.com/romus/sha/blob/master/sha3/src/com/theromus/sha/Keccak.java

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

79

mehrere Smart Contracts sich an einem Oracle registrieren kĂśnnen, um mit Marktdaten
versorgt zu werden.
7.4

Technische Konzeption des Clearinghouse-Smart Contracts

7.4.1 Nicht-funktionale Anforderungen
Robustheit
Die DAPP bzw. der Smart Contract soll bei fehlerhaften Eingaben oder AusfĂźhrung von
Aktionen innerhalb der DAPP sauber terminieren und gegebenenfalls ausgefĂźhrte
Transaktionen rĂźckgĂ¤ngig machen. Dies ist besonders wichtig, wenn die Transaktionen den
Transfer von âEtherâ als Bestandteil haben, wie z.B. bei der der Ăberweisung der initialen
Margin.
IntegritĂ¤t
Die internen Daten des Smart Contracts sollen nur nachvollziehbar geĂ¤ndert werden kĂśnnen.
Diese Anforderung ist zum Teil durch die Nutzung der Blockchain-Technologie eingehalten.
Des Weiteren soll es nur den im Smart Contract fest geschriebenen, vertraulichen Quellen,
dem Oracle, mĂśglich sein, die Preise zu Ă¤ndern.
Besonderheit von Schutz privater Informationen
Eine Besonderheit bei der Nutzung der Blockchain-Technologie ist, dass wie bereits in Kapitel
3.3.1 erwĂ¤hnt, die Daten fĂźr jeden Nutzer im Netzwerk Ăśffentlich sichtbar sind. Daher ist in
Bezug auf den Datenschutz bei einem solchen Vertrage diese Anforderung zu verwerfen, da
die unterliegende Technologie dies ausschlieĂt.
Benutzerfreundlichkeit
Die DAPP soll einfach zu bedienen sein, das heiĂt, ausfĂźhrbare Funktionen des Smart
Contracts sollen sofort ersichtlich und intuitiv bedienbar sein.
7.4.2 Funktionale Anforderungen
Die nachfolgend beschriebenen, funktionalen Anforderungen ergeben sich aus dem im Kapitel
5.2 fachlich konzipierten GeschĂ¤ftsvorfall âSmart Contracts ersetzen Clearinghouse im
Derivatehandelâ. Eine Visualisierung des vollstĂ¤ndigen, verzweigten Ablaufs befindet sich im
Anhang L.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

80

Aufsetzen von Kontrakt
Der grundlegende Smart Contract ohne jegliche Parameter ist in der DAPP fest verankert.
ZusĂ¤tzlich soll es Ăźber die DAPP mĂśglich sein, Smart Contracts mit selbst definierter
Parametern aufzusetzen.
Einzahlung von Margin
Eine grundlegende Funktion ist die Einzahlung der initialen Margin, um den Vertrag aktivieren
zu kĂśnnen. Diese ist gleich oder hĂśher als ein im Smart Contract definierten Prozentsatz vom
eigentlichen Vertragsvolumen. Der Smart Contract soll erst aktiviert werden, wenn von beiden
Vertragsparteien die Margin eingezahlt worden ist. Erst ab diesem Zeitpunkt beginnt die
Laufzeit.
Margin Call
Eine zweite grundlegende Funktion ist der sogenannte âMargin Callâ. Dieser Nachschuss von
weiterem Geld durch eine Partei muss erfolgen, wenn der Kontostand einer Partei unter eine
zuvor definierten âMaintenance Marginâ fĂ¤llt. Die HĂśhe des zu leistenden Nachschusses ist
dabei die Differenz zwischen aktuellem Kontostand und der anfangs eingezahlten Margin.
AuflĂśsung von Kontrakt
Eine weitere wichtige Funktion ist die des Settlements. Nach Ablauf der Laufzeit des Smart
Contracts oder der Naschschuss-Frist sollen âEtherâ der im Smart Contract gespeicherten
KontostĂ¤nde an die Vertragsparteien ausgezahlt werden. Dies entspricht der Funktion eines
Clearinghouses (siehe Kapitel 5.1).
Einspielen von externen Marktdaten
Den Vertragsparteien mĂźssen transparent aktuelle Marktdaten in der DAPP angezeigt werden
kĂśnnen. Hierzu gehĂśren der aktuelle Preis der WĂ¤hrung, die abgesichert werden soll und der
Zeitstempel der letzten Aktualisierung.
Abruf von Kontraktdaten
Den Vertragsparteien sollen alle Informationen Ăźbersichtlich Ăźber den Vertrag in der DAPP
dargestellt werden. Dazu zĂ¤hlen neben den Marktdaten, die aktuellen Angaben zu den
KontostĂ¤nden und ob ein Margin Call erfolgen muss.
Abruf von Teilnehmerdaten
In der DAPP sollen ebenfalls die Account-Daten der einzelnen Vertragsparteien transparent
und Ăźbersichtlich angezeigt werden. Hierzu zĂ¤hlen der Public Key, also die Adresse der
jeweiligen Vertragsparteien in Ethereum, sowie die Position die sie im Kontrakt einnimmt.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

81

7.4.3 Herausforderungen
Informieren Ăźber Frist von Nachschuss von Margin
Aufgrund des Umstandes, dass Smart Contracts nicht Ăźber den gesamten Zeitraum aktiv im
Ethereum-Netzwerk sind, sondern nur, wenn sie von auĂen angestoĂen werden und
anschlieĂend die entsprechenden Operationen ausfĂźhren, ergeben sich EinschrĂ¤nkungen bei
der Einhaltung von Fristen. Hier besteht die Herausforderungen darin, den Vertragsparteien
mitzuteilen, dass z.B. nach einer Aktualisierung des Preises ein Margin Call erfolgen muss. Ein
LĂśsungsansatz hierfĂźr ist, dass die Vertragsparteien in einem bestimmten Intervall die DAPP
aufrufen mĂźssen (z.B. einmal am Tag). Dadurch wird der Vertrag angestoĂen und die
Information Ăźber ein Margin Call zu den Vertragsparteien Ăźbermittelt.
Fristen prĂźfen und durchsetzen
Wie zuvor angesprochen, sind Smart Contracts reaktive Teilnehmer im Ethereum-Netzwerk.
Dadurch ergibt sich eine weitere Herausforderung, weil nur Ăźber Umwege Fristen ĂźberprĂźft
bzw. durchgesetzt werden kĂśnnen. Das Settlement eines Smart Contracts nach Ablauf der
Laufzeit kann z.B. nur dann erfolgen, wenn einer der Vertragsparteien oder eine dritte
unabhĂ¤ngige Partei die jeweilige Funktion des Smart Contracts Ăźber eine Transaktion anstĂśĂt.
Sonst ist dies nicht mĂśglich. Gleiches gilt fĂźr die Einhaltung der Frist fĂźr den Margin Call. Hier
kann es unter UmstĂ¤nden zu verspĂ¤teten Mitteilungen vom Smart Contract zur jeweiligen
Vertragspartei kommen, sodass diese Partei gar nicht die MĂśglichkeit hat, die Frist einzuhalten
und der Vertrag somit aufgelĂśst worden ist. Ein LĂśsungsansatz ist hier, dass der Aufruf
ebenfalls in einem bestimmten Intervall durch die jeweiligen Vertragsparteien erfolgen muss.
Bezahlung von Transaktionskosten fĂźr Marktdaten
Die Aktualisierung des Preises im Smart Contract durch das Oracle ist mit Transaktionskosten
verbunden. Auch die AusfĂźhrung der Operation zur Aktualisierung muss bezahlt werden.
Hierbei stellt sich die Frage, wie der Ablauf erfolgen muss, dass diese Kosten von den
Vertragsparteien Ăźbernommen und bezahlt werden kĂśnnen. Ein LĂśsungsansatz ist, dass die
Vertragsparteien beim Aufsetzen des Vertrages eine bestimmte Summe an âEtherâ zusĂ¤tzlich
zu der initialen Margin einzahlen mĂźssen. Diese Summe wird anschlieĂend vom Smart
Contract bei der Registrierung am Oracle zum Erhalt von Aktualisierungen Ăźberwiesen. Eine
Aktualisierung erfolgt nur solange, wie âEtherâ zur Bezahlung der Transaktionskosten
vorhanden ist. Sollte die Laufzeit lĂ¤nger sein als die eingezahlte Summe, so ist ein Nachschuss
von âEtherâ nĂśtig oder es erfolgen keine Aktualisierungen mehr fĂźr den im Oracle-Smart
Contract registrierten Smart Contract.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

82

7.4.4 Konzeption des Clearinghouse-Smart Contracts
ClearingHouse
uint deadline;
uint currentMarketPrice;
uint totalFunds;
Participant[2] accountMap;
uint margin;
uint currenttotalContractVolume;
uint contractVolume;
bool active;
uint created;
uint activated;
uint deadlineMarginCall;
uint duration;
uint maintenanceMargin;
uint latestMarketPriceUpdate;
uint priceUpdateTimestamp;
address creator;
bool marginCallFreezed;
address escrow;
oraclecontract oracle;
bool oracleRegistrated;

struct participant
2
*

address addr
int balance
int prevBalance
bool MarginCallRequested
bool isBuyer

Clearinghouse()
registerOracle()
updateMarketPrice()
InitialMargin()
marginCall()
settlement(uint price) private
clearing()
marginCallClearing()
kill()

Abbildung 29: Klassendiagramme Clearinghouse Smart Contract

Der Clearinghouse-Smart Contract ist in zwei Klassen unterteilt. Anders als sonst Ăźblich, erbt
die Klasse Clearinghouse nicht von einem âmortalâ-Kontrakt, welcher generalisierte
Funktionen zum Abbau einer Smart Contract-Instanz enthĂ¤lt. Dies ist damit begrĂźndet, dass
zusĂ¤tzliche Logik fĂźr den Abbau einer Instanz notwendig ist (siehe Kapitel 7.5.5).
Des Weiteren werden Daten der Vertragsparteien separat in einem struct-Objekt gespeichert,
das ausschlieĂlich die fĂźr den Kontrakt dynamische, spezifische Daten enthĂ¤lt. Die
Speicherung der Adresse der jeweiligen Vertragspartei ist hierbei notwendig, um eine
eindeutige Zuordnung zu gewĂ¤hrleisten.
Die Variablen im Smart Contract sind mit dem Modifier âpublicâ deklariert. Daraus ergibt sich,
dass diese Ăźber nicht explizit deklarierte Getter-Methoden abgerufen werden kĂśnnen. Die
Setter-Methoden mĂźssen dennoch explizit implementiert werden, da dafĂźr eine Transaktion
im Ethereum-Netzwerk benĂśtigt wird, welche nach Absetzen in der Blockchain von den
âMinernâ bestĂ¤tigt werden muss. Ein Beispiel dafĂźr ist die Aktualisierung des Marktpreises.
Die Funktion âClearingâ ist nur intern im Smart Contract aufrufbar. Dies ist damit begrĂźndet,
weil ausschlieĂlich die Daten der Vertragsparteien in dessen Datenstruktur nach
Aktualisierung des Marktpreises berechnet werden. Alle weiteren Funktionen sind Ăźber
Transaktionen im Ethereum-Netzwerk Ăśffentlich ausfĂźhrbar.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

83

7.4.5 Konzeption der dezentralen Applikation
Softwarearchitektur

Clearinhouse DAPP
clearinghouse.html

clearinghouse.css

clearinghouse.js

Meteor Server

Abbildung 30: Software-Architektur der Clearinghouse DAPP

Der Aufbau der DAPP, fĂźr den zugrundeliegenden Smart Contract des GeschĂ¤ftsvorfalls, folgt
dem durch den von âEmbarkâ mit âMeteorâ vorgegebenen Aufbau. Dies hat zur Folge, dass
aufgrund der geringen KomplexitĂ¤t drei Dateien mit unterschiedlichem Fokus auf einen Teil
der DAPP vorhanden sind. Die Clearinghouse-HTML Datei implementiert die Grundstruktur
der DAPP. Die Struktur der HTML-Seite ist fĂźr die Ăbersichtlichkeit nochmals in sogenannte
Meteor-Templates unterteilt. ZusĂ¤tzlich zu den fĂźr die Interaktion mit einem erstellten Smart
Contract implementierten JavaScript-Funktionen, sind in der Clearinghouse JavaScript-Datei
Helper- und Events- Methoden fĂźr die definierten Templates implementiert. So werden unter
anderem durch Aufruf der Web3-JavaScript-Bibliothek von âEthereumâ im Smart Contract
gespeicherte Werte abgerufen. Die Clearinghouse CSS-Datei dient ausschlieĂlich der
Auslagerung von Design-Definition.
Die extern eingebundenen Meteor-Pakete dienen der einfachen Einbindung und Verwaltung
von JavaScript bzw. CSS-Frameworks oder Bibliotheken. Hierzu zĂ¤hlen das Paket
âtwbs:bootstrapâ, welches das von Twitter entwickelte JavaScript- und CSS-Framework
âBootstrapâ importiert und das Paket âethereum:web3â, welches die JavaScript API fĂźr
âEthereumâ Ăźber das âWeb3â-JavaScript-Objekt fĂźr den Zugriff auf FunktionalitĂ¤ten von
Ethereum bereitstellt. Das Paket âMeteor-Platformâ bildet die Grundlage fĂźr eine auf meteorbasierende DAPP und importiert Standard Meteor-Pakete in das Projekt.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

84

DAPP-OberflĂ¤che
Durch die Zweiteilung der OberflĂ¤che der DAPP in einen Deployment-Teil sowie in einen
Informationsteil wird die Benutzerfreundlichkeit und Ăbersichtlichkeit der Web-Anwendung
gewahrt. Weiter ist wie Abbildung 32 zeigt, der Informationsteil in die drei Unterbereiche
Markt-, Vertrags- und Account-Informationen unterteilt. Damit ist gewĂ¤hrleistet, dass alle
relevanten Informationen fĂźr die Vertragsparteien sofort ermittelt werden kĂśnnen. Im
Gegensatz dazu besteht der Deployment-Teil nur aus einer Eingabemaske fĂźr die Parameter
des zu erstellenden Smart Contracts. Dieser Sachverhalt ist in Abbildung 31 veranschaulicht.

Abbildung 31: Deployment von Kontrakt

Abbildung 32: Kontrakt-Informationen

7.5

Umsetzung des Clearinghouse-DAPP-Prototyps

7.5.1 OberflĂ¤che
Zur Gestaltung der OberflĂ¤che fĂźr die DAPP wird das von Twitter entwickelte und anpassbare
HTML5, CSS und JavaScript-Framework âBootstrapâ als Meteor-Paket eingesetzt. Dadurch ist

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

85

es mĂśglich, mit unterschiedlichen, vordefinierten Designelementen und JavaScriptFunktionen eine einheitliche, dynamische und benutzerfreundliche Web - OberflĂ¤che zu
erstellen, die den Anforderungen an die Benutzerfreundlichkeit genĂźgt. Damit ist die Web OberflĂ¤che Ăźbersichtlich und strukturiert gehalten.
7.5.2 Schutz vor unbefugter AusfĂźhrung und Ănderung
Die Aktualisierung von externen Marktdaten kann nur durch die Ăbergabe als Parameter von
einer zuvor vertraulichen Partei erfolgen. Die fĂźr den GeschĂ¤ftsvorfall benĂśtigten externen
Marktdaten kĂśnnen nur von einer zuvor definierten Oracle-Adresse im Ethereum-Netzwerk
aktualisiert werden. Die Realisierung erfolgt durch eine PrĂźfung der Senderadresse der
jeweiligen Transaktion fĂźr den Aufruf der Funktion des Smart Contracts. Diese Adresse wird
zuvor intern in der Instanz des Smart Contracts gespeichert. Diese Vorgehensweise entspricht
dem âRestricting Accessâ - Pattern von âSolidityâ (EthereumG, 2015).
7.5.3 Aufsetzen des Derivat-Vertrags
Durch die Zweiteilung der DAPP, in die Erstellung und dem Abruf sowie der Interaktion mit
einer Smart Contract-Instanz ist es mĂśglich, dass Nutzer der DAPP weitere Derivat-VertrĂ¤ge
mit definierten Parametern aufsetzen kĂśnnen. Dazu werden in einer Eingabemaske die
Parameter erstellt und nach einem Klick auf den Button eine Instanz des Smart Contracts im
Ethereum-Netzwerk erzeugt. Dabei ist zu beachten, dass der Kontrakt erst nach dem Mining
durch die Nutzer von âEthereumâ erstellt wird. Um eine grĂśĂtmĂśgliche Benutzerfreundlichkeit
in der DAPP zu bieten, wird die Adresse eines zuvor erstellten Smart Contracts in einer
leichtgewichtigen MongoDB17, die im Meteor-Framework integriert ist, gespeichert. Zum
einen muss der Benutzer dadurch nicht selber die Adresse abspeichern, zum anderen wird
ihm die MĂśglichkeit gegeben, in der Informationssicht komfortabel den jeweiligen Smart
Contract auszuwĂ¤hlen.
Des Weiteren ist nach dem Deployment zu beachten, dass die Instanz zwar anschlieĂend in
Ethereum erstellt, aber der eigentliche Vertrag nicht aktiviert worden ist. Der Smart Contract
wird erst aktiviert, wenn beide Vertragsparteien ihre jeweilige initiale Margin eingezahlt
haben. Dies erfolgt Ăźber eine separate Funktion (siehe Kapitel 7.5.4). Hinzukommt, dass die
Transaktionskosten fĂźr das Deployment vom Ersteller Ăźbernommen werden mĂźssen.

17

MongoDB ist eine dokumentenorientierte, NO-SQL Datenbank, welche in Meteor integriert ist,
https://www.mongodb.com/de.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

86

Eine weitere EinschrĂ¤nkung ist, dass der Ersteller des Smart Contracts automatisch der KĂ¤ufer
in Bezug auf den Derivat-Vertrag darstellt. Durch eine generischere Implementierung ist es
mĂśglich, dass die Gegenpartei als KĂ¤ufer definiert wird. FĂźr den Prototyp ist aufgrund des
durch diese Restriktion vereinfachten Testens, dieser Fall vorerst nicht betrachtet worden.
Nach dem Deployment des Smart Contracts ist es ebenso notwendig, dass eine der
Vertragsparteien die Registrierung am Oracle ausfĂźhrt, damit die Aktualisierung des
entsprechenden Marktpreises im Smart Contract erfolgen kann. Dies ist nicht im Deployment
vorgesehen, sondern in eine separate Funktion ausgegliedert worden, weil eine der
Vertragsparteien beim Aufruf eine bestimmte Summe an âEtherâ mitsenden muss. Diese
Summe dient der Bezahlung fĂźr die Aktualisierung des Preises, da dies nur Ăźber eine
Transaktion in Ethereum realisiert werden kann. Die hat zur Folge, dass das Oracle diese
Transaktionskosten Ăźbernehmen muss. Die Implementierung der Registrierungsfunktion ist in
Kapitel 7.5.8 beschrieben.
7.5.4 Einzahlung von Margin
Die auszufĂźhrenden Operationen fĂźr die initiale Margin zur Aktivierung des Vertrags, als auch
der Margin Call unterscheiden sich nur dadurch, dass nach der Einzahlung der initialen Margin
gleichzeitig die Laufzeit des Vertrages beginnt. AnschlieĂend kann die fortlaufende
Aktualisierung der externen Marktdaten, als auch der KontostĂ¤nde der beiden
Vertragsparteien erfolgen. Ansonsten wird in beiden FĂ¤llen geprĂźft, welche der beiden
Vertragsparteien die Margin und in welcher HĂśhe Ăźberwiesen hat. Sollte die HĂśhe der
Einzahlung dem definierten Wert entsprechen, so wird der jeweilige interne Kontostand
angepasst. Dabei richtet sich die HĂśhe an zuvor fest definierten Werten. Im Fall der initialen
Margin ist dies Ăźblicherweise 10 Prozent des Vertragsvolumens. Beim Margin Call ist die HĂśhe
von der Differenz des aktuellen internen Kontostands zur initialen Margin abhĂ¤ngig.
Ansonsten wird die Ăźberwiesene Summe an den Sender zurĂźckĂźberwiesen. Eine zusĂ¤tzliche
Besonderheit beim Margin Call ist, dass das Flag âMarginCallRequested" bei der jeweiligen
Partei wieder auf âfalseâ gesetzt wird.
7.5.5 AuflĂśsen des Derivat-Vertrags
Das Settlement erfolgt, wie bereits in Kapitel 5.2 erwĂ¤hnt, nach Ablauf der zu Beginn
definierten Laufzeit oder wenn eine der beiden Vertragsparteien seiner Pflicht zum
Nachschuss, dem Margin Call, nach einer bestimmten Frist nicht nachkommen sollte. Nach
Ablauf einer dieser beiden Fristen ist es mĂśglich, dass von einer der beiden Vertragsparteien
die Settlement-Funktion der Instanz aufgerufen werden kann. Dies wird Ăźber zwei Modifier
im Smart Contract gewĂ¤hrleistet. Ist dies der Fall, so werden die internen Konten aufgelĂśst

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

87

und die HĂśhe der KontostĂ¤nde auf die jeweiligen Konten der Vertragsparteien in âEthereumâ
Ăźberwiesen. Zu beachten ist hierbei, dass beim Settlement nach einem nicht erfolgten Margin
Call, die HĂśhe der Auszahlung davon abhĂ¤ngt, ob die Vertragspartei, die den Margin Call
durchfĂźhren muss, eine negative Bilanz hat. Sollte dies der Fall sein, so wird der Gegenpartei
die gesamte Menge an âEtherâ, die im Smart Contract vorhanden ist, ausgezahlt. Ist dies nicht
der Fall, so wird jeder Vertragspartei der jeweilige, aktuelle Kontostand ausgezahlt. Dies wird
durch eine Historisierung des vorherigen Kontostandes im Participant-Objekt ermĂśglicht.
AbschlieĂend wird die Instanz durch die interne Funktion âsuicideâ18 im Ethereum-Netzwerk
abgebaut, sodass diese nicht mehr verfĂźgbar bzw. abrufbar ist. Die sich noch in der Instanz
befindliche âEtherâ werden an einen Account gesendet werden. Als Parameter fĂźr die suicideFunktion wird die Adresse des Erstellers des Smart Contracts in Ethereum Ăźbergeben, da
dieser fĂźr die Kosten des Deployments des Smart Contracts in Vorleistung gehen muss.
7.5.6 Abruf von internen Vertragsdaten
Jegliche Vertragsdaten, als auch externe, fĂźr den Vertrag relevante Marktdaten, werden
intern im Smart Contract gespeichert. Dazu zĂ¤hlen unter anderem Vertragsdaten wie z.B.
Vertragsvolumen, Margin, Daten der Vertragsparteien wie z.B. der Kontostand als auch
externe Marktdaten wie z.B. der Preis zu einem bestimmten Zeitpunkt von einer bestimmten
BĂśrse. Die Daten sind Ăźbersichtlich und in drei Kategorien Ăźber die DAPP zu jedem Zeitpunkt
abrufbar. Die Daten liegen Ăźber Transaktionen verteilt auf der unterliegenden Blockchain im
Ethereum-Netzwerk und sind der Instanz des erstellten Smart Contract zugeordnet. Somit
liegen die Daten als Kopie auch bei den Vertragsparteien vor, sodass keine Transaktionskosten
anfallen und kein Transaktion mit abschlieĂendem âMiningâ fĂźr den Abruf nĂśtig ist. Des
Weiteren handelt es sich dabei um einfache Getter-Methoden innerhalb des Smart Contracts,
da die entsprechenden Variablen als public definiert sind. Die Deklaration der Variablen als
private ist mĂśglich, schrĂ¤nkt aber nicht die Sichtbarkeit und den Zugriff auf diese ein, da
sĂ¤mtliche Daten bzw. Inhalte von Transaktionen fĂźr jeden Teilnehmer im Ethereum-Netzwerk
Ăśffentlich sichtbar sind. Dieser Umstand ist durch die darunterliegende Technologie und dem
Prinzip einer Blockchain gegeben.

18

Die suicide-Funktion ist ein von Ethereum bzw. Solidity bereitgestellte Funktion zum Abbau einer
Instanz eines Smart Contracts. Sie dient auĂerdem dem Ăberweisen von noch im Vertrag befindlichen
âEtherâ.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

88

7.5.7 Aktualisierung von Marktdaten durch Dritte
FĂźr den Erhalt von externen Marktdaten ist eine Instanz des Clearinghouse-Smart Contracts
auf eine oder mehrere Oracle-Smart Contracts in âEthereumâ angewiesen. Die Aktualisierung
der internen Marktdaten im Smart Contract kann dabei Ăźber zwei unterschiedliche AblĂ¤ufe
erfolgen. In beiden FĂ¤llen muss die Instanz von auĂen reaktiviert werden, damit die
entsprechenden Operationen ausgefĂźhrt werden kĂśnnen. Zum einen kann eine der
Vertragsparteien die Aktualisierungsfunktion Ăźber die DAPP aufrufen, wodurch anschlieĂend
die Instanz, die Funktion zum Abruf eines bestimmten Datums eines definierten Oracles
aufruft und so den gewĂźnschten Wert erhĂ¤lt. Der Vorteil ist dabei, dass die Vertragsparteien
nur beim jeweiligen Aufruf fĂźr die Transaktionskosten aufkommen mĂźssen.
Andererseits kann es unter UmstĂ¤nden in diesem Szenario dazu kommen, dass z.B. der Preis
an einem Tag nicht aktualisiert wird. Aus diesem Grund wird das zweite Szenario, welches
durch Abbildung 33 veranschaulicht wird, fĂźr die Aktualisierung von externen Marktdaten
angewendet. Dabei wird, wie bereits erwĂ¤hnt, die jeweilige Instanz an einem Oracle
registriert. Das Oracle ruft in einem bestimmten Intervall die Funktion zur Aktualisierung des
Preises auf. So ist gewĂ¤hrleistet, dass z.B. der Preis und die KontostĂ¤nde unabhĂ¤ngig von den
beiden Vertragsparteien aktualisiert werden. Die Transaktionskosten fĂźr den mehrmaligen
Aufruf der Funktion zur Aktualisierung im Smart Contract werden zu Beginn der Laufzeit von
einer der Vertragsparteien der Instanz Ăźberwiesen und anschlieĂend bei der Registrierung
dem Oracle weitergeleitet.

Abbildung 33: Oracle initiiert Preisaktualisierung

Des Weiteren erfolgt nach der Aktualisierung des Preises die Berechnung der internen
KontostĂ¤nde der Vertragsparteien, das Clearing (siehe Kapitel 5.2). Sollte der berechnete
interne Kontostand nach dem Clearing unterhalb einer zuvor definierten âMaintenance

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

89

Marginâ fallen, so wird das Flag âMarginCallRequestedâ gesetzt Dem jeweiligen Benutzer wird
dann in der DAPP angezeigt, dass ein Nachschuss erfolgen muss. Gleichzeitig wird ebenfalls
die Ablauffrist âdeadlineMarginCallâ auf einen definierten Zeitpunkt gesetzt bis zu dem der
Margin Call erfolgen muss. AuĂerdem wird das Flag âMarginCallFreezedâ gesetzt, sodass in
diesem Zeitraum keine Aktualisierung von externen Marktdaten erfolgen kann.
7.5.8 Registrierung am Oracle
Die Registrierung der Smart Contract-Instanz an einem Oracle besteht nur aus einer
Transaktion die von der Instanz an das Oracle gesendet wird. Diese FunktionalitĂ¤t ist in einer
separaten Funktion und nicht bei dem Deployment des Smart Contracts realisiert. Sie muss
explizit durch eine der Vertragsparteien vor der Einzahlung der initialen Margin aufgerufen
werden. Dies ist damit begrĂźndet, dass bei der Registrierung eine bestimmte Summe an
âEtherâ an das Oracle Ăźberwiesen werden muss, welche als Bezahlung der Transaktionen fĂźr
die Aktualisierung des Preises dient. Dieser Umstand hat ebenfalls zur Folge, dass eine der
Vertragsparteien in Vorauszahlung geht und damit mehr âEtherâ aufwenden muss als die
Gegenpartei. Die Transaktion beinhaltet die Adresse der Instanz des Smart Contracts sowie
die Summe an âEtherâ, die zur Bezahlung der Transaktionskosten nĂśtig ist. Wie in Kapitel 7.3.3
ausgefĂźhrt, erfolgt eine Aktualisierung nur solange wie genĂźgend âEtherâ zur VerfĂźgung
gestellt wird. Dadurch kann es unter UmstĂ¤nden dazu kommen, dass keine Aktualisierung des
Preises nach einer bestimmten Laufzeit erfolgt. Aus dem diesem Grund hĂ¤ngt die Summe an
âEtherâ, die mit gesendet wird, von der Laufzeit des Vertrages ab. Die HĂśhe muss von den
Vertragsparteien in AbhĂ¤ngigkeit der Laufzeit und der Kosten fĂźr diese Transaktion selbst
errechnet und als Wert bei der Registrierung eingetragen werden. Eine Nachzahlung fĂźr
weitere Preisaktualisierung ist im gegenwĂ¤rtigen Kontrakt nicht implementiert, sodass
genĂźgend âEtherâ zu Beginn Ăźberwiesen werden muss.
7.6

Kritische Reflexion und Ausblick

Der grĂśĂte Kritikpunkt liegt in der Verarbeitung von Zahlen. Im Smart Contract bzw. der DAPP
sind keine Gleitkommazahlen vorgesehen, sondern die Preise mĂźssen exakt auf eine kleinere
Einheit umgerechnet worden sein. Intern findet dieser Umrechnungsschritt im Smart Contract
oder in der DAPP nicht statt. Die EinschrĂ¤nkungen bezĂźglich der Verwendung von
ausschlieĂlich ganzen Zahlen hat ihren Ursprung in der Benutzung von Solidity als
Programmiersprache. Diese sieht keine Gleitkommazahlen-Datentypen vor. In Ethereum
werden jegliche WĂ¤hrungen z.B. von âEtherâ in die kleinste Einheit âWeiâ umgerechnet. Dies
hat zur Folge, dass mit sehr groĂen Zahlen gerechnet werden muss.
Ein inhaltlicher Kritikpunkt ist, dass die Werte fĂźr die initiale Margin mit zehn Prozent, als auch
die âMaintenance Marginâ mit fĂźnf Prozent des zugrundeliegenden Vertragsvolumens bei der

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

90

Erstellung des Smart Contracts im Quellcode fest definiert sind. Damit soll gewĂ¤hrleistet
werden, dass keine Gleitkommazahlen wegen der zuvor geschilderten EinschrĂ¤nkung
bezĂźglich âSolidityâ vorhanden sind. Durch eine Parametrisierung kĂśnnen diese Werte
dynamisch gehalten werden. Dabei bleibt allerdings das Problem mit den Gleitkommazahlen
bestehen und fĂźhrt unter UmstĂ¤nden zu ungewollten Rundungen.
Ein weiterer Kritikpunkt sind die teilweise umstĂ¤ndlichen Workflows. Hier ist das grĂśĂte
Verbesserungspotential vorhanden. Zum Beispiel sollte die Registrierung am Oracle nicht
separat durch eine der Vertragsparteien aufgerufen werden mĂźssen, sondern schon zum
Zeitpunkt des Deployments des Smart Contracts erfolgen. Des Weiteren kann es unter
UmstĂ¤nden dazu kommen, dass ein Vertrag zu spĂ¤t aufgelĂśst wird, wenn z.B. eine der
Vertragsparteien seinem Margin Call nicht nachkommt, da die dafĂźr zustĂ¤ndige Funktion
explizit durch einen der Vertragsparteien im Smart Contract aufgerufen werden muss.
Allerdings ist dieser Umstand durch die PassivitĂ¤t von Smart Contract-Instanzen bedingt,
wodurch es vorerst keine LĂśsung gibt.
Als Erweiterung kann eine Historisierung von Marktpreisen sowie der einzelnen KontostĂ¤nde
in der Instanz des Smart Contracts in Betracht gezogen werden. Dadurch ist es mĂśglich, dass
durch entsprechende Visualisierung mit einer Grafik-Bibliothek wie z.B. C3.js19, die
Entwicklung im Zeitverlauf Ăźbersichtlich und komfortabel den Vertragsparteien prĂ¤sentiert
werden kann.

19

C3.js, eine auf D3.js basierende Grafik-Bibliothek, http://c3js.org.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

8

SEITE

91

Fazit

Die Blockchain als Basis einer KryptowĂ¤hrung oder auch als Basis integritĂ¤tsgesicherter r
Daten innerhalb von erweiterten Transaktionen kann je nach Einsatzgebiet, verwendeter
Sicherheitsrichtlinien und Art der Implementierung nahezu absolute Sicherheit, oder auch
einfachste AngriffsmĂśglichkeiten bieten.
Seit 2009 entwickelt sich die Blockchain-Technologie stetig weiter. Wie bei jeder neuen
Technologie tauchen mit zunehmender Verbreitung neue Problematiken auf. Die
erforderliche Skalierbarkeit wird dabei fĂźr bereits jetzt groĂe KryptowĂ¤hrungen wie den
Bitcoin eine Herausforderung. Hierunter fallen Limitierungen in der maximalen Aufnahme von
Transaktionen pro Sekunde, sowie die steigende Anforderung an RechenkapazitĂ¤t fĂźr die
Sicherheit des Netzwerks.
Der Einsatz neuester Kryptografieverfahren, wie dem SHA3 Hash im Rahmen des Proof-ofWork, kann sich wie im Bitcoin-Netzwerk positiv auf die Sicherheit auswirken und gleichsam
einen Ă¤uĂerst verschwenderischen Umgang mit Ressourcen mit sich bringen. Der Einsatz
alternativer Implementierungen, beispielsweise mit Proof-of-Stake, vermindert den
Ressourceneinsatz unter Schaffung von VertrauensverhĂ¤ltnissen gegenĂźber vermĂśgenden
Teilnehmern. Die stetige Entwicklung an weiteren teils hybriden Konzepten wirkt sich dabei
positiv auf die Sicherheit und auch den Energieverbrauch aus.
Trotz berechtigter Kritik bietet die Blockchain-Technologie, nicht nur fĂźr den Einsatz in Bezug
auf digitale WĂ¤hrungen, groĂes Potential. So kĂśnnen ebenfalls auf der Blockchain-Technologie
reale GeschĂ¤ftsvorfĂ¤lle durch Smart Contracts realisiert werden. Die Smart ContractPlattformen und Programme fĂźr Smart Contracts befinden sich in einem frĂźhen Stadium der
Entwicklung. Es gibt viele Ideen und Projekte, allerdings sind diese zum gegenwĂ¤rtigen
Zeitpunkt bei weitem noch nicht fĂźr Endbenutzer geeignet. Einige Finanzdienstleister nehmen
sich diesem Thema vermehrt an. Auch mit der Verbreitung des Begriffs âInternet of Thingsâ
gibt es ebenfalls viele AnwendungsfĂ¤lle, die auĂerhalb der Finanzbranche mĂśglich sind.
Allerdings stehen diese Forschungen und Entwicklungen groĂen Herausforderungen wie z.B.
der rechtlichen und physischen Durchsetzbarkeit gegenĂźber. Einen Nutzen haben Smart
Contracts Ăźberwiegend dort, wo schĂ¤dliche Manipulationen mĂśglich sind oder einem
Mittelsmann vertraut werden muss. In solchen AnwendungsfĂ¤llen kĂśnnen Smart Contracts
aufgrund ihrer DezentralitĂ¤t und dem im Quellcode fest definierten Verhalten, das Risiko
minimieren.
Komplexe, wie in der Ausarbeitung entwickelte und implementiere, GeschĂ¤ftsvorfĂ¤lle sind nur
mit EinschrĂ¤nkungen realisierbar. So ist z.B. der Bezug von externen Daten auĂerhalb

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

92

der Blockchain nur Ăźber Umwege, wie ein Smart Oracle, mĂśglich. Einfache GeschĂ¤ftsvorfĂ¤lle,
wie z.B. ein Treuhand-Vertrag, sind dahingegen uneingeschrĂ¤nkt realisierbar.
Die Auswahl des GeschĂ¤ftsvorfalls hat eine hohe Praxisrelevanz. Dies zeigt sich durch die
beiden US-amerikanischen Startup-Unternehmen Hitfin und Hedgy, welche parallel zu diesem
Projekt LĂśsungen fĂźr den Derivatehandel auf Basis der Blockchain entwickeln.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

93

Literaturverzeichnis
Ateniese, G., Kamara, S., & Katz, J. (2009). Proofs of Storage from Homomorphic Identification
Protocols.

Abgerufen

am

10.

Dezember

2015

von

https://cs.umd.edu/~jkatz/papers/pdp.pdf
Back, A. (01. August 2002). Hashcash - A Denail of Service Counter-Measure. Hashcash - A
Denail of Service Counter-Measure. Von Hashcash.org: http://hashcash.org/ abgerufen
Bentov, I., Lee, C., Mizrahi, A., & Rosenfeld, M. (2014). Proof of Activity: Extending Bitcoinâs
Proof of Work via Proof of Stake. Abgerufen am 05. November 2015 von
https://eprint.iacr.org/2014/452.pdf
Bertani, T. (4. November 2015). Oraclize Blog. Abgerufen am 11. November 2015 von
http://blog.oraclize.it/2015/11/04/oraclize-official-launch/
Berwanger, J. (kein Datum). Gabler Wirtschaftslexikon - juristische Person. Abgerufen am 25.
Januar

2016

von

http://wirtschaftslexikon.gabler.de/Definition/juristische-

person.html
Bitcoin.org. (2015a). Double-spending. Abgerufen am 10. Februar 2016 von bitcoinwiki:
https://en.bitcoin.it/wiki/Double-spending
Bitcoin.org. (2015b). Weaknesses. Abgerufen am 05. Januar 2016 von bitcoinwiki:
https://en.bitcoin.it/wiki/Weaknesses
Bitcoin.org-A. (kein Datum). Bitcoin.org - Developer Guide - Blockchain. Abgerufen am 10. 02
2016

von

Bitcoin.org

-

Developer

Guide

-

Blockchain:

https://bitcoin.org/en/developer-guide#block-chain
Bitcoin.org-B. (kein Datum). Bitcoin.org - Wie es funktioniert. Abgerufen am 10. 02 2016 von
Bitcoin.org - Wie es funktioniert: https://bitcoin.org/de/wie-es-funktioniert
Bitcoinwiki-A. (kein Datum). Bitcoinwiki - Bitcoin Core. Abgerufen am 10. 02 2016 von
Bitcoinwiki - Bitcoin Core: https://en.bitcoin.it/wiki/Bitcoin_Core
Bitcoinwiki-B. (kein Datum). Bitcoinwiki - Block hashing algorithm. Abgerufen am 10. 02 2016
von

Bitcoinwiki

-

Block

hashing

algorithm:

https://en.bitcoin.it/wiki/Block_hashing_algorithm
Bitcoinwiki-C. (kein Datum). Bitcoinwiki - Blockchain. Abgerufen am 10. 02 2016 von
Bitcoinwiki - Blockchain: https://en.bitcoin.it/wiki/Block_chain
Bitcoinwiki-D. (10. Februar 2015). Bitcoinwiki - ECDSA. Abgerufen am 10. Februar 2016 von
Bitcoinwiki

-

https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm

ECDSA:

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

94

Bitcoinwiki-E. (kein Datum). Bitcoinwiki - Hashcash. Abgerufen am 10. 02 2016 von Bitcoinwiki
- Hashcash: https://en.bitcoin.it/wiki/Hashcash
Bitcoinwiki-F. (kein Datum). Bitcoinwiki - Message Structure. Abgerufen am 10. 02 2016 von
Bitcoinwiki - Message Structure: Bitcoinwiki - Message Structure
Bitcoinwiki-G. (kein Datum). Bitcoinwiki - Mining. Abgerufen am 10. 02 2016 von Bitcoinwiki Mining: https://en.bitcoin.it/wiki/Mining
Bitcoinwiki-H. (kein Datum). Bitcoinwiki - Proof-of-Work. Abgerufen am 10. 02 2016 von
Bitcoinwiki - Proof-of-Work: https://bitcoin.org/en/developer-guide#proof-of-work
Bitcoinwiki-I. (kein Datum). Bitcoinwiki - Script Flow Control. Von Bitcoinwiki - Script Flow
Control: https://en.bitcoin.it/wiki/Script#Flow_control abgerufen
Bitcoinwiki-K. (kein Datum). Bitcoinwiki - Target. Abgerufen am 10. Februar 2016 von
Bitcoinwiki - Target: https://en.bitcoin.it/wiki/Target
Bitcoinwiki-L. (28. Mai 2015). Bitcoinwiki - Transaktionen. Abgerufen am 10. Februar 2016 von
Bitcoinwiki - Transaktionen: https://en.bitcoin.it/wiki/Transaction
Bitcoinwiki-M. (2016). Bitcoin Wiki - Script. Abgerufen am 10. 02 2016 von
https://en.bitcoin.it/wiki/Script
Bitcoinwiki-N. (2016). Bitcoin Wiki - Block size limit controversy. Abgerufen am 26. Februar
2016 von https://en.bitcoin.it/wiki/Block_size_limit_controversy
Blockchaincenter. (2016). Blockchaincenter - BlockchaingrĂśĂe. Abgerufen am 10. Februar
2016

von

Blockchaincenter

-

BlockchaingrĂśĂe:

http://www.blockchaincenter.de/fragen/wie-gross-ist-die-blockchain/
Boehm, F., & Pesch, P. (2014). Bitcoin: A First Legal Analysis. 1st Workshop on Bitcoin Research
in Assocation with Financial Crypto.
Burst. (2015). Burst. Abgerufen am 01. Februar 2016 von http://burstcoin.info/
CoingeckoA. (kein Datum). Coingecko.com. Abgerufen am 26. Januar 2016 von
https://www.coingecko.com/en/coins/bitcoin
CoingeckoB. (kein Datum). Conigecko.com. Abgerufen am 26. Januar 2016 von
https://www.coingecko.com/en/coins/ethereum
Coinmarketcap. (kein Datum). Coinmarketcap.com. Abgerufen am 30. September 2015 von
Coinmarketcap.com: http://coinmarketcap.com/all/views/all/
Cordell, D. (30. Oktober 2014). HDD Poof of Capacity Mining, is it viable? Abgerufen am 17.
Januar 2016 von https://www.cryptocoinsnews.com/hdd-proof-of-capacity-miningviable/

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

95

Counism. (23. MĂ¤rz 2014). Why Proof-of-Burn. Abgerufen am 05. Januar 2016 von
http://counterparty.io/news/why-proof-of-burn/
Decker, C., & Wattenhofer, R. (2013). Information Propagation in the Bitcoin Network.
Information Propagation in the Bitcoin Network.
Decker, C., & Wattenhofer, R. (2013). Information Propagation in the Bitcoin Network. Zurich,
Schweiz.

Abgerufen

am

25.

Oktober

2015

von

http://diyhpl.us/~bryan/papers2/bitcoin/Information%20propagation%20in%20the%
20Bitcoin%20network.pdf
Eikenberg,

R.

(20.

Dezember

2015).

l+f:

Bitcoin-App

Blockchain

generierte

Gemeinschaftskonto. (h. Security, Hrsg.) Abgerufen am 30. Dezember 2015 von
http://www.heise.de/security/meldung/l-f-Bitcoin-App-Blockchain-generierteGemeinschaftskonto-2678065.html
Eris Industries. (2016). Explainer - Permissioned Blockchains. Abgerufen am 26. Februar 2016
von https://docs.erisindustries.com/explainers/permissioned_blockchains
Ernst, N. (16. Juni 2014). 51 Prozent der Rechenleistung fĂźr Bitcoin in einer Hand. (golem.de,
Hrsg.) Abgerufen am 03. Januar 2016 von http://www.golem.de/news/ghash-51prozent-der-rechenleistung-fuer-bitcoin-in-einer-hand-1406-107217.html
Ethereum. (21. November 2015). Ethereum Whitepaper. Abgerufen am 18. Januar 2016 von
https://github.com/ethereum/wiki/wiki/White-Paper#messages-and-transactions
EthereumC. (2015). Ethereum Whitepaper - A Next-Generation Smart Contract and
Decentralized Application Platform. Abgerufen am 03. Februar 2016 von
https://github.com/ethereum/wiki/wiki/White-Paper
EthereumD. (2015). Ethereum Whitepaper - Code Execution. Abgerufen am 03. Februar 2016
von https://github.com/ethereum/wiki/wiki/White-Paper#code-execution
EthereumD.

(2015).

Go-Ethereum

Wiki.

Abgerufen

am

03.

Februar

2016

von

2016

von

https://github.com/ethereum/go-ethereum/wiki
EthereumE.

(2015).

Mist

Browser.

Abgerufen

am

03.

Februar

https://github.com/ethereum/mist
EthereumF. (2015). Mix: The DApp IDE. Abgerufen am 03. Februar 2016 von
https://github.com/ethereum/wiki/wiki/Mix:-The-DApp-IDE
EthereumG. (2015). Solidity - Restricting Access. Abgerufen am 09. Februar 2016 von
http://solidity.readthedocs.org/en/latest/common-patterns.html#restricting-access

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

96

EthereumH. (2015). Solidity Documentation. Abgerufen am 03. Februar 2016 von
https://solidity.readthedocs.org/en/latest/
EuropĂ¤ische Zentralbank. (kein Datum). Euro foreign exchange reference rates. Abgerufen am
20.

Januar

2016

von

https://www.ecb.europa.eu/stats/exchange/eurofxref/html/index.en.html
Eurostat. (22. Januar 2016). Electricity production, consumption and market overview.
Abgerufen am 10. Februar 2016 von http://ec.europa.eu/eurostat/statisticsexplained/index.php/Electricity_production,_consumption_and_market_overview
Gray, M. (2015). Abgerufen am 26. Januar 2016 von Ethereum Blockchain as a Service now on
Azure:

https://azure.microsoft.com/de-de/blog/ethereum-blockchain-as-a-service-

now-on-azure/
HeldtA, C. (kein Datum). Gabler Wirtschaftslexikon - DifferenzgeschĂ¤ft. Abgerufen am 18.
Januar 2016 von http://wirtschaftslexikon.gabler.de/Archiv/4512/differenzgeschaeftv9.html
HeldtB, C. (kein Datum). Gabler Wirtschaftslexikon - Kursrisiko. Abgerufen am 11. Januar 2016
von http://wirtschaftslexikon.gabler.de/Definition/kursrisiko.html
Honsel, G. (2015). Bitcoin: Die Banken drehen den SpieĂ um. Abgerufen am 26. Januar 2016
von

http://www.heise.de/newsticker/meldung/Bitcoin-Die-Banken-drehen-den-

Spiess-um- 2825544.html
Hull, J. (2015). Optionen, Futures und andere Derivate. Hallbergmoos: Pearson.
ITWissen. (11. Februar 2016). Zugriffszeit. Abgerufen am 11. Februar 2016 von ITWissen Das
groĂe

Online-Lexikon

fĂźr

Informationstechnologie:

http://www.itwissen.info/definition/lexikon/Zugriffszeit-access-time.html
Johnston, D., Onat Yilmaz, S., Kandah, J., Bentenitis, N., Hashemi, F., Gross, R., . . . Mason, S.
(2014). The General Theory of Decentralized Applications, Dapps. Abgerufen am 20.
Januar 2016 von https://github.com/DavidJohnstonCEO/DecentralizedApplications
Kannenberg, A. (16. Februar 2015). Angriffsziel BitcoinbĂśrse: Bter und Exco.in gehackt. (h.
online,

Hrsg.)

Abgerufen

am

28.

Dezember

2015

von

http://www.heise.de/newsticker/meldung/Angriffsziel-Bitcoinboerse-Bter-und-Excoin-gehackt-2550175.html
Kosba, A., Miller, A., Shi, E., Wen, Z., & Papamanthou, C. (2015). Hawk: The blockchain model
of cryptography and privacy-preserving smart contracts. University of Maryland and
Cornell University.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

97

Koschyk, H. (27. September 2013). www.frank-schaeffler.de. Von http://www.frankschaeffler.de/wp-content/uploads/2013/10/2013_09_27-Antwort-KoschykBitcoin3.pdf abgerufen
Maxim, J. (2015). Ripple Discontinues Smart Contract Platform Codius, Citing Small Market.
Abgerufen am 20. Januar 2016 von https://bitcoinmagazine.com/articles/ripplediscontinues-smart-contract-platform-codius-citing-small-market-1435182153
Miller, S. M., & Stiegler, M. (2003). The Digital Path: Smart Contracts and the Third World.
Abgerufen am 26. Januar 2016 von http://www.erights.org/talks/pisa/paper
MĂźnzer,

J.

(19.

Dezember

2013).

BaFin.

Von

http://www.bafin.de/SharedDocs/Veroeffentlichungen/DE/Fachartikel/2014/fa_bj_1
401_bitcoins.html abgerufen
Nakamoto, S. (2009). Bitcoin: A Peer-to-Peer Electronic Cash System. Bitcoin: A Peer-to-Peer
Electronic Cash System.
Nxt Community. (2015). Nct. Abgerufen am 02. Februar 2016 von http://nxt.org/
OâDwyer, K. J., & Malone, D. (2014). Bitcoin Mining and its Energy Footprint. (H. I. Maynooth,
Hrsg.)

Abgerufen

am

28.

Dezember

2015

von

https://karlodwyer.github.io/publications/pdf/bitcoin_KJOD_2014.pdf
O'Dwyer, K. J., & Malone, D. (26-27. Juni 2014). Bitcoin Mining and its Energy Footprint. Bitcoin
Mining and its Energy Footprint. Limerick.
Oracle. (2010). Class String. Abgerufen am 08. Januar 2016 von docs.oracle.com:
http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html#hashCode%28%
29
Orisi. (29. November 2014). Orisi White Paper. Von https://github.com/orisi/wiki/wiki/OrisiWhite-Paper abgerufen
Orisi. (17. Januar 2016). The Oracle List. Von http://oracles.li/# abgerufen
P4Titan. (17. Mai 2014). Slimcoin A Peer-to-Peer Crypto-Currency with Proof-of-Burn.
Abgerufen

am

10.

Februar

2016

von

https://decentralgroup.com/archive_files/whitepaper%20(4).pdf
Patterson, R. (26. August 2015). Alternatives for Proof of Work, Part 2: Proof of Activity, Proof
of Burn, Proof of Capacity, and Byzantine Generals. Abgerufen am 30. Dezember 2015
von https://bytecoin.org/blog/proof-of-activity-proof-of-burn-proof-of-capacity/
Peercoin. (14. MĂ¤rz 2015). Peercoin wiki. Abgerufen am 08. Februar 2016 von
https://wiki.peercointalk.org/index.php?title=Main_Page

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

98

QuantumMechanic. (11. Juli 2011). Proof of stake instead of proof of work. Abgerufen am 14.
Oktober 2015 von Bitcoin Forum: https://bitcointalk.org/index.php?topic=27787.0
Reality KeysA. (kein Datum). Reality Keys - About. Abgerufen am 19. Januar 2016 von
https://www.realitykeys.com/about
Reality KeysB. (kein Datum). Reality Keys - Developer Resources and Examples. Abgerufen am
19. Januar 2016 von https://www.realitykeys.com/developers/resources#ethereum
Reality KeysC. (kein Datum). Reality Keys - Pricing. Abgerufen am 16. Januar 2016 von
https://www.realitykeys.com/pricing
Ripple Labs. (17. Juli 2014). Smart Oracles: A Simple, Powerful Approach to Smart Contracts.
Abgerufen am 19. Januar 2016 von https://github.com/codius/codius/wiki/SmartOracles:-A-Simple,-Powerful-Approach-to-Smart-Contracts
Schmeh, K. (2013). Kryptograpfie - Verfahren, Protokolle, Infrastrukturen. Heidelberg: dpunkt
Verlag.
SchĂśning, S. (kein Datum). Gabler Wirtschaftslexikon - WĂ¤hrungsrisiko. Abgerufen am 18.
Januar 2016 von http://wirtschaftslexikon.gabler.de/Archiv/9441/waehrungsrisikov9.html
Swan, M. (2015). Blockchain - Blueprint for a New Economy. OâReilly Media Verlag.
Szabo, N. (1998). Formalizing and Securing Relationships on Public Networks. Abgerufen am
26. Januar 2016 von http://szabo.best.vwh.net/formalize.html
TLSNotary. (11. November 2015). TLSNotary. Von https://tlsnotary.org/ abgerufen
von Uhruh, C.-N. (2015). The Law of Bitcoin. Bloomington: iUniverse.
Vossen, G., & Weikum, G. (2001). Fundamentals of Transactional Information Systems. San
Diego: Academic Press.
Wood Dr., G. (2014). Ethereum - A secure decentralised generalised Transaction Ledger.
Abgerufen am 09. Februar 2016 von http://gavwood.com/paper.pdf

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

99

Anhang
A. Analyse aktueller KryptowĂ¤hrungen
Die Ergebnisse der Analyse der KryptowĂ¤hrungen liegen als Excel-Datei âAnhang A - Analyse
aktueller KryptowĂ¤hrungen.xlsxâ vor.
B. Transaktionen
Die Beispiele und Visualisierungen zum Bereich Transaktionen liegen als Visio-Datei âAnhang
B-E Transaktionen, BlĂścke, Dezentrales Netzwerk, Kryptografie.vsdxâ vor.
B.1 â Transaktionen im Zeitverlauf (VerknĂźpfung von Input und Output)
B.2 â PrĂźfung einer Transaktionssignatur
B.3 â Erstellen eines Transaktionshashes
C. BlĂścke
Die Beispiele und Visualisierungen zum Bereich BlĂścke liegen als Visio-Datei âAnhang B-E
Transaktionen, BlĂścke, Dezentrales Netzwerk, Kryptografie.vsdxâ vor.
C.1 â Berechnung des Hashbaums (Merkle Root)
C.2 â Berechnung des Schwierigkeitsgrades
C.3 â Hashcash-Algorithmus
C.4 â PrĂźfen eines Blockhashes
C.5 â Blockgenerierung im Zeitverlauf
D. Dezentrales Netzwerk
Die Beispiele und Visualisierungen zum Bereich Dezentrales Netzwerk liegen als Visio-Datei
âAnhang B-E Transaktionen, BlĂścke, Dezentrales Netzwerk, Kryptografie.vsdxâ vor.
D.1 â Verbinden mit dem Netzwerk
D.2 â Initialer Blockdownload
D.3 â Transaktionen senden und empfangen

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

100

E. Kryptografie
Die Beispiele und Visualisierungen zum Bereich Kryptografie liegen als Visio-Datei âAnhang BE Transaktionen, BlĂścke, Dezentrales Netzwerk, Kryptografie.vsdxâ vor.
E.1 â Digitale Signaturen (Beispiel RSA)
E.2 â Kryptografische Hashfunktion (SHA256)
F. Entwicklungsumgebung fĂźr den Blockchain-Prototyp
Typ

Name

Version

Quelle/Link

Programmiersprache

Java

1.8.0_66

http://www.oracle.com/de/java/over
view/index.html

Java Bibliothek

java.net

Java 1.7

https://docs.oracle.com/javase/7/doc
s/api/java/net/packagesummary.html

Java Bibliothek

java.nio.file

Java 1.7

https://docs.oracle.com/javase/7/doc
s/api/java/nio/file/packagesummary.html

Java Bibliothek

org.json

20141113

http://www.json.org/

Framework

Log4j

1.2.17

http://logging.apache.org/log4j/

Entwicklungsumgebung

Eclipse Luna 4.4.2

Eclipse https://eclipse.org/luna/

Build-Management-Tool

Apache
Maven

https://maven.apache.org/

3.2.1

Tabelle 5: Entwicklungsumgebung

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

G. Komponenten-/Klassendiagramme der Blockchain-Anwendungen

LAN

Handshake

Miner

Datenempfang

Datenversendung

Steuerung

Persistenz

Blockgenerierung

Daten
Abbildung 34: Komponenten-Diagramm des Miners

101

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

Host

BlockGenerator

- String address
- int port

- Thread generationThread;
- GenerateSingleBlock
generateSingleBlock
- boolean active

- Host(JSONObject)
- getAddress() : String
- getPort() : int

- BlockGenerator()
- startGeneration() : void
- stopGeneration() : void
- interruptCurrentGeneration() : void

Controller

NetworkSender

- static List<Chain> alternativeChains
- static Chain chain
- static BlockGenerator blockGenerator
- static Queue queue
- static NetworkReceiver receiver
- static NetworkSender sender
- static int minerAddress
- static List<Host> hosts
- static String localChainPath
- static Logger logger

- Socket socket
- List<Host> hosts

- NetworkSender(List<Host>)
- sendBlock(Block) : void
[- sendBlock(Block, String, int)]
[- getBlock(Long)]

GenerateSingleBlock
- run()

Block
- int powDifficulty
- long number
- int prehash
- int blockhash
- int transactionhash
- int pow
- List<Transaction> transactions
- long powTime
- int producersAddress

- static main(String[])
[- readConfiguration() : void]

NetworkReceiver
- boolean listening
- ServerSocket serverSocket
- int port

Chain

- NetworkReceiver(int)
- run() : void
- cancel() : void

- List<Block> blockchain
- Chain()
- Chain(JSONArray)
- Chain(List<Block>)
- Chain getClone()
- getLastBlock() : Block
- getOldBlock(int) : Block
0..1
- size() : int
- getJSON() :JSONArray
- getTransactionInputs(int) : List<TransactionInput>
- isTransactionInputValid(int, int, int) : boolean
- isInputFree(int, int) : boolean
- isInputFree(int, int, Block) : boolean
- equals() : boolean
[- readBlockchain() : void]
[- getLastValidBlock() : int]
[- createGenesisBlock() : void]
[- writeBlockchain() : void]

ServerThread
- Socket socket
- ServerThread(Socket)
- run() : void
[- getInputStreamString() : String]
[- sendOutputStreamString(String) : void]
[- interpretData(String) : String]
[- addTransaction(JSONObject) : void]
[- handleBlock(JSONObject) : void]
[- mergeChains(Block, Chain) : void]
[- mergeChains(List<Block>, Chain) : void]
[- switchToAlternativeChain(Block) : void]
[- switchToAlternativeChain(List<Block>) :
void]
[- clearAlternativBlockchains() : void]
[- addNewBlocksToChain(List<Block>,
Chain) : void]
[- getBlockchain() : String]

0..1
1..*

- long number
- int from
- int hash
- List<TransactionInput> inputs
- List<TransactionOutput> outputs
0..*

- Queue()
- addTransaction(Transaction) : void
- getClone() : List<Transaction>
- deleteTransactions(int) : void

- Block(int, long, int, int, long)
- Block(JSONObject)
- getJSON() : JSONObject
- addTransaction(int, List<TransactionInput>,
List>TransactionOutput>) : void
- finalizeBlock() : void
[- addMiningTransaction : void]
[- setTransactionHash() : void]
- getTransactionHash() : int
- getValueTo(int) : int
[- proofOfWork(int, int) : int]
[- startsWithNZeros(int, int) : boolean]
- compareTo(Block) _ int
- equals(Block) : boolean

0..*

Transaction

Queue
- List<Transaction> queue

102

0..1

- Transaction(int, int, long,
List<TransactionInput>, List<TransactionOutput>)
- Transaction(JSONObject)
- isReward() : int
- getJSON() : JSONObject
- compareTo(Transaction) : int
- getHashCode(int) : int
1
1..*

Transaction Input

1..*

Transaction Output

- int inputHash
- int inputValue

- int outputTarget
- int outputValue

- TransactionInput(int, int)
- TransactionInput(JSONObject)
- getInputHash() : int
- getInputValue() : int
- getJSON() : JSONObject
- hashCode() : int

- TransactionOutput(int, int)
- TransactionOutput(JSONObject)
- getOutputTarget() : int
- getOutputValue() : int
- getJSON() : JSONObject
- hashCode() : int

Abbildung 35: Klassendiagramm Mininganwendung

KRYPTOWĂHRUNGEN UND SMART CONTRACTS
NetworkSender

SEITE

Block

Controller

- Socket socket

- static clientAddress
- static List<Host> hosts
- static Chain blockchain
- static NetworkSender sender
- static List<TransactionInputs> freeInputs
- static int inputSum

- getBlockchain(List<Host>) : void
- sendTransaction(List<Host>,Transaction) : boolean
- sendToHost(String, int, String) : String

0..*

- static main(String[])
- static interpretInput(String) : void
- initiateTransaction(int, int) : void
- firstWord(String) : void
- getHelp() : String
- refreshInputSum() : void
- readConfiguration() : void
- getTransaction() : void

Host
- String address
- int port
- Host(JSONObject)
- getAddress() : String
- getPort() : int

- int powDifficulty
- long number
- int prehash
- int blockhash
- int transactionhash
- int pow
- List<Transaction> transactions
- Block(JSONObject)
- compareTo(Block) _ int
0..1

1..*

Transaction
- long number
- int from
- int hash
- List<TransactionInput> inputs
- List<TransactionOutput> outputs

Chain
- List<Block> blockchain
- Chain(JSONArray)
- getAllTransactionOutputs(int) : List<>
- getAllTransactionInputs(int) : List<>
- isInputFree(int, int) : boolean
- isInputFree(int, int, Block) : boolean

103

0..1

- Transaction(int, int, long, List<>, List<>)
- Transaction(JSONObject)
- getJSON() : JSONObject
1
1..*

Transaction Input
- int inputHash
- int inputValue
- int from
- TransactionInput(int, int)
- TransactionInput(int, int, int)
- TransactionInput(JSONObject)
- getInputHash() : int
- getInputValue() : int
- getFrom() : int
- getJSON() : JSONObject

Abbildung 36: Klassendiagramm der Wallet-Anwendung

1..*

Transaction Output
- int outputTarget
- int outputValue
- TransactionOutput(int, int)
- TransactionOutput(JSONObject)
- getOutputTarget() : int
- getOutputValue() : int
- getJSON() : JSONObject

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

MainView

Controller

BlockSegmentBranch

- public static Stage primaryStage
- static int resolutionX
- static int resolutionY
- final static int PADDING
- static BlockchainView blockchainView

- static int m1S
- static int m2S
- static int m3S
- static main(String[]) : void

Block[] branches
public BlockSegmentBranch(int)
public get() : Block
public get(int) : Block
public set(Block) : void
public set(Block, int) : void

- public run() : void
- public alterBlock(int, Block, int) : void
- public refreshView() : void
- public start(Stage) : void
- private init(Stage) : void

Block

Receiver
- static boolean listening
- static ServerSocket serverSocket

- Color color
- String text
- int number

BlockchainView

- public start() : void
- private handleLogIncome(String) : void
- private parseMiner(int)
- private handleLog(int, String, int, String)
: void

- int x
- int y
- Canvas canvas
- GraphicsContext gc
- int numberOfBranches
- List<BlockSegmentBranch> miner1
- List<BlockSegmentBranch> miner2
- List<BlockSegmentBranch> miner3

ServerThread extends Thread

public Block(Color, String, int)
public getColor() : Color
public getText() : String
public getNumber() : int

- public BlockchainView(int, int)
- public BlockchainView(int, int, Color)
- protected getBlackCanvas() : Canvas
- private clearCanvas() : void
- protected updateBlocks() : void
- private reduceSize(List) : void
- private deleteLowEntrys(int,List) : void
- private drawBlockLine(List, int) : void
- private drawBlock(int, int, int, Color,
String) : void
- drawArrow(int, int, int, Color) : void
- protected alterBlock(int,Block,int) : void
- private alterBlock(List, Block, int) : void
- private getPosition(List, int) : int

- Socket socket

- public ServerThread(Socket)
- public run() : void
- private getInputStreamString() : String

LAN

Abbildung 37: Klassendiagramm Visualisierungsanwendung

H. Blockgenerierung der Mining-Anwendungen
Start

End

inactiv
generation
active generation

Blockgeneration

generation
successfull
Delay
generation
aborted

Abbildung 38: Blockgenerierung Ăbersicht

104

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

Abbildung 39: Blockgenerierung Detailansicht

SEITE

105

KRYPTOWĂHRUNGEN UND SMART CONTRACTS
I. Angriff auf die prototypische Blockchain

Abbildung 40: Angriff auf den Prototyp - Erscheinen des Angreifers

Abbildung 41: Angriff auf den Prototyp - Angreifer ist gleichauf

SEITE

106

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

Abbildung 42: Angriff auf den Prototyp - Angreifer beeinflusst Miner 1

Abbildung 43: Angriff auf den Prototyp - Angreifer beeinflusst Miner 2

SEITE

107

KRYPTOWĂHRUNGEN UND SMART CONTRACTS
J.

SEITE

108

(Kompilierter) Quellcode der Blockchain Anwendungen

Der Quellcode der Mining-Anwendung liegt als zip-Archiv âmining_code.zipâ, der Quellcode
der Visualisierungsanwendung als zip-Archiv âvisualisierung_code.zipâ und die WalletAnwendung als zip-Archiv âwallet_code.zipâ vor.
Zudem liegen die kompilierten Anwendungen samt Konfigurationsanleitung (readme.txt) als
zip-Archiv âblockchain-kompilate.zipâ vor.

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

109

K. Tabellarischer Vergleich der Frameworks
Typ

Arten

Funktionsumfang
Kompilieren/Deploymen
t von Smart Contracts?
(zzl. Packages, Out-ofthe-Box)

Meteor
Full Stack
Framework,
JavaScript App
Plattform

generisch fĂźr
DAPPs

intern per web3
Object (Ăźber
Ethereum
Packages) oder
extern (per geth
oder Packages
(embark))

Testing?

Deployment/VerĂśffentlic Unbundle von
hung DAPP?
Code oder
Bundling als
Meteor Client
(Packages:
meteor-buildclient)
Debugging von Smart
keine DIE
Contracts/Code?
Deployment Testnet?
geth-abhĂ¤ngig,
theoretisch auch
TestRPC Client
mĂśglich

Embark
framework that
allows you to
easily develop
and deploy
Ethereum
DAPPs
Fokus von
DAPPs auf
Ethereum

Truffle
Development
environment, testing
framework and asset
pipeline for Ethereum
(DAPPs)

integriert (alle
.sol - Dateien im
Contract Ordner
werden deployt
mit einem
Befehl)

integriert, nutzt als
Abstraktion Pudding
(https://github.com/Cons
enSys/ether-pudding)

UnterstĂźtzt
Test-Driven
Development
von Contracts
Ăźber eigene JS
Lib, fĂźr JS
Default:
Jasmine, andere
mĂśglich
Unbundled

Mocha (Tests) Chai
(Assertions), TestRPC
Client fĂźr automated
Testing

keine DIE

keine DIE

integriert per
Befehl,
Spezifikation in
Datei,
theoretisch
TestRPC Client
mĂśglich

mittels TestRPC Client,
Spezifikation in Datei

Fokus von DAPPs auf
Ethereum

distributable version of
app (minified)

KRYPTOWĂHRUNGEN UND SMART CONTRACTS
UnterstĂźtzte Sprachen
fĂźr Smart Contract?
API?

Handhabung
Live Reloading?*
Generalisierung Smart
Contracts?

Integration von
Artefakten (JS)?
Struktur von DAPP

Reifegrad/Verbreitung
Nutzer?
Version?
Erweiterbarkeit?

EntwicklungsaktivitĂ¤t/
Wartung/Weiterentwic
klung
Commiter?
Letzter Commit?
Road Map?
Unternehmen?

Solidity
Ethereum Web3
(Ăźber Packages)

integriert
extern, out-ofthe-box nicht
mĂśglich

SEITE

Solidity,
(Serpant)
Ethereum Web3
integriert

Solidity

integriert
integriert
(Ablage in
Verzeichnis,
deploy per
Befehl)
im Code/Ordner

integriert
integriert

110

Pudding (Abstraktion fĂźr
Web3)

Ăźber Meteorim Code/Order
Packages oder im
Code
ziemlich Ă¤hnlich, bis auf, dass Embark und Truffle ein Verzeichnis
haben, wo Smart Contracts abgelegt werden, die automatisch
deployt werden kĂśnnen

EthereumDev
1.2.1

EthereumJ-Dev

-

1.0.2

0.0.4

Ăźber Meteor
-Packages
(z.B.
Ethereum
web3 Objekt)

per Javascript-Libs
im Code, Ethereum
integriert

per Javascript-Libs im
Code, Ethereum integriert

249
04.12.2015

14
06.12.2015

6
04.12.2015

Open Source?

Meteor
Development
Group
ja
ja

AbhĂ¤ngigkeiten zu
Installation? (z.B. NPM?)

-

geth (1.1.0), solc
(0.1.0) or serpent

ConsenSys

ja, MIT

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

Deployment DAPP?
Interaktion/Deployment
Ethereum?

Entwicklungsprozess
(Default) Workflow?
(Einfachheit)

Umfang
ToolunterstĂźtzung (z.B.
IDE)?
Deploymentprozess
Workflow? (Einfachheit)
/ Umfang?

Vorbereitungen
ToolunterstĂźtzung (z.B.
IDE)?

AusfĂźhrung von
Artefakten(DAPP,
Client)
Bundling in Client?
Vorraussetzungen?

Besonderheit

mittels RPC
Ăźber z.B.
geth

(develop), node
(0.12.2) and npm
mittels RPC Ăźber z.B.
geth

SEITE

111

mittels RPC Ăźber z.B. geth

Per
Texteditor,
Befehle
Kommandoze
ile
Develop,
Deploy, Test
-

Per Texteditor,
Befehle
Kommandozeile

Per Texteditor, Befehle
Kommandozeile

Develop, Deploy,
Test
-

Develop, Deploy, Test

Smart
Contracts
Ăźber Geth
oder per
Package
(Embark)

integriert, per Befehl integriert, per Befehl

-

-

-

mĂśglich
Installation
von Meteor
als
AusfĂźhrungs
umgebung

Installation Embark

Installation Truffle

https://githu
b.com/hitchc
ott/meteorembark,
Integration

RPC Simulator

Abstraktions-Layer mit
Pudding fĂźr Interaktion
mit Smart Contracts

-

KRYPTOWĂHRUNGEN UND SMART CONTRACTS
von Embark
Framework
als Package
in Meteor
Doku

AusfĂźhrliches Wiki

*Ănderungen werden
erkannt und DAPP neu
geladen
Test RPC Client
(pyethereum Basis)

https://githu
b.com/Conse
nSys/ethtestrpc
Tabelle 6: Vergleich der Frameworks

SEITE

Wiki

112

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

L. Technischer Basis-Workflow der DAPP

Deploy Contract

IntitialMargins

Durch Oracle
durchgefĂźhrt
updateMarketPrice

Frist erreicht?

nein
nein

Clearing

nein

ja

ja

MarginCallRequested?

Benutzer ZahlungsfĂ¤hig?
ja

nein

MarginCall

Frist erreicht?

Settlement

SettlementMarginCall

ja

killContract

Abbildung 44: Basis-Workflow Clearinghouse DAPP

113

KRYPTOWĂHRUNGEN UND SMART CONTRACTS

SEITE

114

M. Quellcode der Clearinghouse-DAPP
Der

Quellcode

der

Clearinghouse-DAPP

liegt

als

zip-Archive

âclearinghouse_dapp_artefakte_ct.zipâ vor.
N. BPMN-Diagramm des GeschĂ¤ftsvorfalls
Das BPMN-Diagramm ist aufgrund seiner GrĂśĂe als Anlage zu dieser Arbeit in der Datei âBPMN
â GeschĂ¤ftsvorfall.pdfâ zu finden.
O. BPMN-Diagramm des Unterprozess prĂźfe KontostĂ¤nde

Abbildung 45: Unterprozess prĂźfe KontostĂ¤nde

P. BPMN-Diagramm des Smart Oracles
Das BPMN-Diagramm ist aufgrund seiner GrĂśĂe als Anlage zu dieser Arbeit in der Datei âBPMN
â Smart Oracle.pdfâ zu finden.
Q. Quellcode des Smart Oracles
Der Quellcode befindet sich in der Datei âOracle.zipâ

